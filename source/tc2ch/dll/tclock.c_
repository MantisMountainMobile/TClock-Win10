/*-----------------------------------------------------
  tclock.c
  customize the tray clock
  KAZUBON 1997-2001
-------------------------------------------------------*/
#include "tcdll.h"
#include <math.h>
#include <physicalmonitorenumerationapi.h>

#include    <wingdi.h>
#pragma     comment(lib,"msimg32.lib")

#define GRADIENT_FILL_RECT_H    0x00000000
#define GRADIENT_FILL_RECT_V    0x00000001

#define MAX_PROCESSOR               64

//グラフの記録数
#define MAXGRAPHLOG 600
#define MAX_MYCOLORS 16

//IDTIMERDLL_CHECKNETSTAT, IDTIMERDLL_SYSINFOのオフセット(ms)	added by TTTT
#define OFFSETMS_TIMER_SYSINFO	200
#define OFFSETMS_TIMER_NETSTAT	500



char Ver_TClockWin10[16];


extern PSTR CreateFullPathName(HINSTANCE hmod, PSTR fname);

LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WndProcSubClk(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

void InitClock(HWND hwnd);

void CreateClockDC(void);
void ReadData(void);
void InitSysInfo(void);

void OnTimer_Win10(void);	//added by TTTT

void OnTimerUpperTaskbar(void);
static void DrawClockFocusRect(HDC hdc);
void DrawClockSub(HDC hdc, SYSTEMTIME* pt, int beat100);
void DrawGraph(HDC hdc, int xclock, int yclock, int wclock, int hclock);

//LRESULT OnCalcRect(void);		//3.5.0.1で廃止。一応しばらく残しておく。

void UpdateSysRes(BOOL bsysres, BOOL bbattery, BOOL bmem, BOOL bmb, BOOL bpermon, BOOL bnet, BOOL bhdd, BOOL bcpuc, BOOL bvol);

void GetTimeZoneBias_Win10(void);


void getGraphVal();

void OntimerCheckNetStat_Win10(HWND hwnd); //added by TTTT

void SendStatusDLL2Main(void);

void DisableAllSubClocks(void);
void DisableSpecificSubClock(int i);


void GetOrigSubClkDimensions(void);

void StoreSpecificSubClockDimensions(int i);

//void GetTaskbarMainDimensions(void);

void GetOrigMainClockSize(void);

void CalcMainClockContentSize(void);

void CalcMainClockSize(void);

void ActivateSubClocks(void);

void FindAllSubClocks(void);

void RedrawMainTaskbar(void);

void RedrawTClock(void);

void SetTClockFont(void);

BOOL GetInkWorkspaceSetting(void);










static BOOL bTooltipTimerStart = FALSE;
extern BOOL bEnableTooltip;



void CheckSafeMode_Win10(void);	// added by TTTT

BOOL b_ExistLTEProfile = FALSE;
BOOL b_ExistMeteredProfile = FALSE;

BOOL b_UsageRetrieveInternetProfile = TRUE;

int AdjustThreshold = 200;
BOOL b_FlagTimerAdjust = FALSE;

/*------------------------------------------------
  shared data among processes
--------------------------------------------------*/
#ifdef _MSC_VER
#pragma data_seg("MYDATA")
//dllmainと共有するデータ(dllの共有データ？)はこのdata_segの中に入れる必要があり、また宣言時に初期化が必要
HHOOK hHookMain = 0;
HWND hwndTClockExeMain = NULL;
HWND hwndTaskBarMain = NULL;
HWND hwndTrayMain = NULL;
HWND hwndHookMain = NULL;
BOOL bMainClockHooked = FALSE;
BOOL bWin11 = FALSE;

char szShareBuf[81] = { 0 };
#pragma data_seg()
#else
extern HWND hwndTClockExeMain;
extern HWND hwndTaskBarMain;
#endif


//以下の配列の初期化はFindAllSubClocksのループの中で行う。
HWND hwndTaskBarSubClk[MAX_SUBSCREEN];
HWND hwndClockSubClk[MAX_SUBSCREEN];
BOOL bSubClockFound[MAX_SUBSCREEN];
BOOL bEnableDrawSubClk[MAX_SUBSCREEN];

int numberSubClk = 0;

int heightSubClock[MAX_SUBSCREEN];
int widthSubClock[MAX_SUBSCREEN];

int widthMainClockContent, heightMainClockContent;
int widthMainClockFrame, heightMainClockFrame;
RECT rectMainClock;

BOOL bEnableSubClks = FALSE;

/*------------------------------------------------
  globals
--------------------------------------------------*/
HANDLE hmod = 0;
HWND hwndClockMain = NULL;
WNDPROC oldWndProc = NULL;
WNDPROC oldWndProcSub[MAX_SUBSCREEN] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };


BOOL bTimer = FALSE;
BOOL bTimerDLLMainAdjust = FALSE;
HDC hdcClock = NULL;
HDC hdcClock_work = NULL;
;
static HGDIOBJ hbmpClockOld = NULL;
HBITMAP hbmpClock = NULL;

HBITMAP hbm_DIBSection = NULL;
HBITMAP hbm_DIBSection_work = NULL;

HFONT hFon = NULL;
COLORREF colback, colback2, colfore;
BOOL fillbackcolor = FALSE;
DWORD grad;

BOOL bTimerCheckNetStat = FALSE;	//Added by TTTT

BOOL bTimerAdjust_SysInfo = FALSE;
BOOL bTimerAdjust_NetStat = FALSE;


COLORREF ColorWeekdayText = RGB(0, 0, 0);
COLORREF ColorSaturdayText = RGB(0, 0, 0);
COLORREF ColorSundayText = RGB(0, 0, 0);
COLORREF ColorHolidayText = RGB(0, 0, 0);
COLORREF ColorVPNText = RGB(0, 0, 0);

COLORREF textcol_DoWzone = RGB(0, 0, 0);

BOOL bSaturday = FALSE;
BOOL bSunday = FALSE;
BOOL bHoliday = FALSE;
BOOL b_DayChange = FALSE;



// add by 505 =================================
static BOOL bGetingFocus = FALSE;




enum {
	ANALOG_CLOCK_NOTREAD,
	ANALOG_CLOCK_NOTUSE,
	ANALOG_CLOCK_USE
};
enum {
	ANALOG_CLOCK_POS_LEFT,
	ANALOG_CLOCK_POS_RIGHT,
	ANALOG_CLOCK_POS_MIDDLE
};
#define ACLOCK_SIZE_CX	18
#define ACLOCK_SIZE_CY	18
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4)
int nAnalogClockUseFlag = ANALOG_CLOCK_NOTREAD;

SIZE sizeAClock = { 0, 0 };
int nAnalogClockPos = ANALOG_CLOCK_POS_LEFT;
static HDC hdcAnalogClock = NULL;
static HBITMAP hbmpAnalogClock = NULL;
static HBITMAP hbmpAnalogClockMask = NULL;
static HDC hdcAnalogClockMask  = NULL;
static LPBYTE lpbyAnalogClockMask = NULL;
static int nHourPenWidth = 2;
static int nMinPenWidth = 1;
static HPEN hpenHour = NULL;
static HPEN hpenMin = NULL;
static int nAnalogClockHPos = 0;
static int nAnalogClockVPos = 0;
static COLORREF colAClockHourHandColor = RGB(255, 0, 0);
static COLORREF colAClockMinHandColor = RGB(0, 0, 255);
static TCHAR szAnalogClockBmp[MAX_PATH] = "";
static SIZE  sizeAnalogBitmapSize = { 0, 0 };
static BOOL InitAnalogClockData(HWND hWnd);


static BOOL bGraphTimerStart = FALSE;
char format[1024];



BOOL bHour12, bHourZero;
SYSTEMTIME LastTime;
int beatLast = -1;
int bDispSecond = FALSE;
int nDispBeat = 0;

int nBlink = 0;

int dwidth = 0, dheight = 0, dvpos = 0, dlineheight = 0, dclkvpos = 0;
//int iClockWidth = -1;

BOOL bDispSysInfo = FALSE, bTimerSysInfo = FALSE;
BOOL bGetSysRes = FALSE, bGetBattery = FALSE, bGetMem = FALSE,
     bGetMb = FALSE, bGetPm = FALSE, bGetNet = FALSE, bGetHdd = FALSE, bGetCpu = FALSE, bGetVol = FALSE;
int iFreeRes[3] = {0,0,0}, iCPUUsage = 0, iBatteryLife = 0, iVolume = 0;
extern int CPUUsage[];

BOOL b_SoundCapability = TRUE;
int iCPUClock[MAX_PROCESSOR] = {0};
MEMORYSTATUSEX msMemory;
//BOOL bWatchTaskWnd = FALSE;
BOOL bClockShadow = FALSE;
BOOL bClockBorder = FALSE;
BOOL bVolRedraw = FALSE;
int nShadowRange = 1;
COLORREF colShadow;
int nTextPos = 0;

BOOL bRClickMenu = FALSE;
int tEdgeTop;
int tEdgeLeft;
int tEdgeBottom;
int tEdgeRight;

//Addby ひまじん
BOOL checknet=FALSE;
BOOL bGraph = FALSE;
BOOL bLogGraph = FALSE;
BOOL bGraphTate = FALSE;
BOOL bReverseGraph = FALSE;
BOOL bGraphRedraw = FALSE;
int NetGraphScaleRecv = 100;
int NetGraphScaleSend = 100;
int GraphL=0;
int GraphT=0;
int GraphR=0;
int GraphB=0;
int GraphType=1;
double sendlog[MAXGRAPHLOG+1] = { 0 };
double recvlog[MAXGRAPHLOG+1] = { 0 };
int ColSend,ColRecv,ColSR;
int graphInterval = 1;
int graphMode = 1;
int cpuHigh;

extern HWND hwndStart;
extern HWND hwndStartMenu;


extern int codepage;

// XButton Messages
#define WM_XBUTTONDOWN                  0x020B
#define WM_XBUTTONUP                    0x020C


// Added by TTTT for Win10AU (WIN10RS1) compatibility
#define SUBCLASSTRAY_ID		2
int     g_winver = WIN10;              // Windows version, currently set as WIN10(non AU)

BOOL    g_bTaskbarPosChanging = FALSE;
BOOL    g_bVertTaskbar = FALSE;        // vertical taskbar ?
//BOOL	g_bVertTaskbarSub[MAX_SUBSCREEN];
BOOL	g_bVertTaskbarSub;

int     origWidthMainClock;      // original clock width
int     origHeightMainClock;      // original clock height

int		origSubClockWidth[MAX_SUBSCREEN], origSubClockHeight[MAX_SUBSCREEN];
int		widthSubTaskbar[MAX_SUBSCREEN], heightSubTaskbar[MAX_SUBSCREEN];


LRESULT CALLBACK SubclassTrayProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
BOOL IsVertTaskbar(HWND hwndTaskBarMain);

static void SetMainClockOnTasktray();

void SetSubClocksOnTaskbars(void);
void SetSpecificSubClock(int i);

int GetSubClkIndexFromHWND(HWND tempHwndSubClk);

void CalcSpecificSubClockSize(int i);









BOOL b_UseDataPlanFunction = FALSE;

BOOL b_dataPlanFixedDayInMonth = FALSE;

int g_InternetConnectStat_Win10 = -1;	//added for Internet Connectionstatus by TTTT
char icp_SSID_APName[32];
char activeSSID[32];
char activeAPName[32];

// IP addresses added by TTTT
char ipLTE[32];
char ipEther[32];
char ipWiFi[32];
char ipVPN[32];



double dataPlanUsageInMegabyte; //added for DataPlan Usage by TTTT

int dataPlanContractYear = 2018;		//to be stored in Reg and ini file
int dataPlanContractMonth = 1;		//to be stored in Reg and ini file
int dataPlanContractDay = 23;		//to be stored in Reg and ini file

int dataPlanLimitInMegabyte = 5120;	//to be stored in Reg and ini file
int dataPlanLimitDays = 360;	//to be stored in Reg and ini file
int dataPlanBillingPeriodDays = 30;		//to be stored in Reg and ini file

int dataPlanExpirationYear = -1;		//to be caluculated in startup
int dataPlanExpirationMonth = -1;		//to be caluculated in startup
int dataPlanExpirationDay = -1;		//to be caluculated in startup

int dataPlanDaysInContract = -1;		//to be caluculated in startup

int dataPlanThisCycleEndYear = -1;		//to be caluculated in startup
int dataPlanThisCycleEndMonth = -1;		//to be caluculated in startup
int dataPlanThisCycleEndDay = -1;		//to be caluculated in startup

int dataPlanDaysInBillingPeriod = 0;;
int dataPlanBillingPeriodNumber = 0;


int specifiedRetrieveProfNum = 6;
int currentLTEProfNum = -1;
int UsageRetrieveProfileNumber = -1;
int previousLTEProfNum = 0;


int internetConnectProfNum = -1;

int profileNumber_WiFi = -1;
int profileNumber_Ethernet = -1;

int digitDataPlanInGB = 2;
int megabytesInGigaByte = 1000;

BOOL b_DebugLog = FALSE;
BOOL b_DebugLog_RegAccess = FALSE;
BOOL b_DebugLog_Specific = FALSE;


// Added by TTTT
BOOL b_EnableStopCloudApp = FALSE;
BOOL b_ControlledAppStopped = FALSE;



char g_mydir_dll[MAX_PATH]; // path to tclock.exe

int dataPlanChkPeriod_Win10 = 10;

char strCloudExe1[MAX_PATH];
char strCloudExe2[MAX_PATH];
char strCloudExe3[MAX_PATH];
char strCloudExe4[MAX_PATH];
char strCloudExe5[MAX_PATH];


char strSoftEtherKeyword[32];
char strVPN_Keyword1[32];
char strVPN_Keyword2[32];
char strVPN_Keyword3[32];
char strVPN_Keyword4[32];
char strVPN_Keyword5[32];

char strVPN_Exclude1[32];
char strVPN_Exclude2[32];
char strVPN_Exclude3[32];
char strVPN_Exclude4[32];
char strVPN_Exclude5[32];

char strEthernet_Keyword1[32];
char strEthernet_Keyword2[32];
char strEthernet_Keyword3[32];
char strEthernet_Keyword4[32];
char strEthernet_Keyword5[32];




BOOL b_CompactMode = TRUE;


BOOL b_SafeMode = FALSE;

BOOL b_ExcessNetProfiles = FALSE;

BOOL muteStatus = FALSE;	//added by TTTT for volume

char strBuf[32];
char strLTE[32];
char charLTE[32];
char strMute[32];


BOOL b_MeteredNetNow = FALSE;

BOOL b_DataPlanUsageRetrieving = FALSE;

BOOL b_AutoClearLogFile = TRUE;
int AutoClearLogLines = 1000;
int LogLineCount = 1000;

char strDispStatus[32];
char strDispSingle[32];
char strDispClone[32];
char strDispExtend[32];
char strDisp2ndOnly[32];

char previousLTEProfName[256];

BOOL b_NormalLog = FALSE;		//added by TTTT

// For BarMeter Added by TTTT
//Color Chart
//黒：0
//灰色：12632256
//薄い灰色：12632256
//白：16777215
//赤：255
//紺色：8388608
//青：16711680
//水色：16776960
//緑：65280
//黄色：65535
//ピンク：16711935

BOOL b_UseBarMeterBL = FALSE;
BOOL b_BatteryLifeAvailable = TRUE;

COLORREF ColorBarMeterBL_Charge = RGB(255, 165, 0);
COLORREF ColorBarMeterBL_High = RGB(0, 0, 255);
COLORREF ColorBarMeterBL_Mid = RGB(0, 255, 0);
COLORREF ColorBarMeterBL_Low = RGB(255, 0, 0);
int BarMeterBL_Left = 230;
int BarMeterBL_Right = 220;
int BarMeterBL_Bottom = 0;
int BarMeterBL_Top = -1; 



BOOL b_BarMeterVL_Horizontal = FALSE;
BOOL b_BarMeterBL_Horizontal = FALSE;
BOOL b_BarMeterCU_Horizontal = FALSE;
BOOL b_BarMeterNet_Horizontal = FALSE;




BOOL b_UseBarMeterCU = FALSE;
COLORREF ColorBarMeterCU_High = RGB(255, 0, 0);
COLORREF ColorBarMeterCU_Mid = RGB(0, 0, 255);
COLORREF ColorBarMeterCU_Low = RGB(0, 255, 0);
int BarMeterCU_Left = 210;
int BarMeterCU_Right = 200;
int BarMeterCU_Bottom = 0;
int BarMeterCU_Top = -1;

BOOL b_UseBarMeterCore = FALSE;
int NumberBarMeterCore = 10;
COLORREF ColorBarMeterCore_High = RGB(255, 0, 0);
COLORREF ColorBarMeterCore_Mid = RGB(0, 0, 255);
COLORREF ColorBarMeterCore_Low = RGB(0, 255, 0);
int BarMeterCore_Left = 200;
int BarMeterCore_Right = 190;
int BarMeterCore_Bottom = 0;
int BarMeterCore_Top = -1;
int BarMeterCore_Pitch = 5;

BOOL b_UseBarMeterVL = FALSE;
int ColorBarMeterVL = RGB(0, 255, 0);
int ColorBarMeterVL_Mute = RGB(255, 0, 0);
int BarMeterVL_Left = 260; 
int BarMeterVL_Right = 250;
int BarMeterVL_Bottom = 0;
int BarMeterVL_Top = -1;


BOOL b_UseBarMeterNet = FALSE;
int ColorBarMeterNetRecv = RGB(0, 255, 0);
int ColorBarMeterNetSend = RGB(255, 0, 0);
int BarMeterNetRecv_Left = 305;
int BarMeterNetRecv_Right = 300;
int BarMeterNetRecv_Bottom = 0;
int BarMeterNetRecv_Top = -1;
int BarMeterNetSend_Left = 315;
int BarMeterNetSend_Right = 310;
int BarMeterNetSend_Bottom = 0;
int BarMeterNetSend_Top = -1;
BOOL b_BarMeterNet_LogGraph = FALSE;


void DrawBarMeter(HWND hwnd, HDC hdc, int wclock, int hclock, int bar_right, int bar_left, int value, COLORREF color);
void DrawBarMeter2(HWND hwnd, HDC hdc, int wclock, int hclock, int bar_right, int bar_left, 
	int bar_bottom, int bar_top, int value, COLORREF color, BOOL b_Horizontal);

extern BOOL b_Charging;


COLORREF MyColorTT[MAX_MYCOLORS];

COLORREF MyColorTT_CU();
COLORREF MyColorTT_VL();
COLORREF MyColorTT_BL();

COLORREF MyColorTT_Core(int iCPU);


void CALLBACK myMonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData);


BOOL b_FlagDispClone;

BOOL bGetDispInfo = TRUE;

int NetBarMeterSend, NetBarMeterRecv;

extern double net[];

int LogDigit = 4;
int LogDigit2 = 4;


int DataPlanUsageRetrieveMode = 0;

BOOL b_ImmediateUsageUpdate = FALSE;

BOOL b_DataPlanRetreveOK = TRUE;

int NetMIX_Length = 10;
int SSID_AP_Length = 10;


BOOL b_WarnDelayedUsageRetrieval = FALSE;

BOOL b_BlinkDataUsage = TRUE;
BOOL b_FlagBlinkDataUsage = FALSE;

int TimerCountForSec = 1000;
int intervalTimerAdjust = 0;
BOOL b_InitialTimerAdjust = FALSE;

BOOL b_ModernStandbySupported = FALSE;
BOOL b_Sleeping = FALSE;



//void OnWindowPosChanging(HWND hwnd, LPWINDOWPOS pwp);		//20191207 Ver3371 TTTT

int offsetBottomOfMeter = 0;


BOOL IsHoliday_Win10(SYSTEMTIME* pt);



extern BOOL flag_VPN;
BOOL b_English = FALSE;

static RGBQUAD* m_color_start = NULL, *m_color_end;
static RGBQUAD* m_color_work_start = NULL, *m_color_work_end;


BOOL b_System_Light_Theme = FALSE;
BOOL b_Apps_Light_Theme = FALSE;
BOOL b_Transparency_Theme = FALSE;

char strAdditionalMountPath[10][64];

COLORREF colorBG_original = RGB(0, 0, 0);



int currentTimeZoneBiasMin = 0;
int timezoneBiasMin[256];


int iHourTransition = -1, iMinuteTransition = -1;


void Textout_Tclock_Win10(int xcenter, int y, char* sp, COLORREF textshadow, COLORREF textcol_temp);

void Textout_Tclock_Win10_2(int xcenter, int y, char* sp, COLORREF textshadow, COLORREF textcol_temp);







/*------------------------------------------------
  initialize the clock
--------------------------------------------------*/
void InitClock(HWND hwnd)
{
	//hwndの実体はhwndHookMainしかあり得ず、またこれがtclock.c内のhwndClockMainとなる。
	//SubClassTrayProcおよびWndProcSubClkの場合だけ
	WIN32_FIND_DATA fd;
	HANDLE hfind;
	char fname[MAX_PATH];
	BOOL b;
	DWORD dw;
	int nDelay;

	//RECT rc;	// Added by TTTT for Win10AU (WIN10RS1) compatibility


	if(hwndClockMain != NULL) return;

	//以降は初回のみ動作。hwndClockMain

	hwndClockMain = hwnd;
	g_winver = CheckWinVersion_Win10();       // Modified by TTTT for more reliable versioncheck


	GetModuleFileName(hmod, fname, MAX_PATH);
	del_title(fname);
	add_title(fname, "tclock-win10.ini");
	hfind = FindFirstFile(fname, &fd);
	if(hfind != INVALID_HANDLE_VALUE)
	{
		g_bIniSetting = TRUE;
		strcpy(g_inifile, fname);
		FindClose(hfind);
	}

	//SafeModeチェック
	CheckSafeMode_Win10();

	//レジストリ読み込み
	ReadData();


	CpuMoni_start(); // cpu.c
	PerMoni_start(); // permon.c
	Net_start();     // net.c


	//サブディスプレイ上タスクバー時計のフック
	if (bEnableSubClks) {
		FindAllSubClocks();
	}

	//メインタスクバーの方向をチェック

	g_bVertTaskbar = IsVertTaskbar(hwndTaskBarMain);

	//サブタスクバーはメインとサブが両方横の場合のみ表示する
	for (int i = 0; i < numberSubClk; i++) {
		if (g_bVertTaskbar == IsVertTaskbar(hwndTaskBarSubClk[i])) {
			if (bSubClockFound[i]) bEnableDrawSubClk[i] = TRUE;
		}
		if (b_DebugLog) {
			writeDebugLog_Win10("[tclock.c][InitClock] Sub Screen ID = ", i);
			writeDebugLog_Win10("[tclock.c][InitClock] bEnableDrawSubClk[i] = ", bEnableDrawSubClk[i]);
		}
	}

	//改造対象のサブ時計起動時点のサイズを保存(メインは終了時にWindowsがサイズ調整するので保持不要。あくまで動作中の差分計算用なのでここでは取得しない。
	GetOrigSubClkDimensions();

	//PostMessage(hwndTClockExeMain, WM_USER, 0, (LPARAM)hwnd);
	PostMessage(hwndTClockExeMain, WM_USER, 0, (LPARAM)hwndClockMain);


	//if (b_DebugLog) {
	//	int dispx = GetSystemMetrics(SM_CXSCREEN);
	//	int dispy = GetSystemMetrics(SM_CYSCREEN);
	//	writeDebugLog_Win10("[tclock.c][InitClock] ScreenWidth = ", dispx);
	//	writeDebugLog_Win10("[tclock.c][InitClock] ScreenHeight = ", dispy);

	//	GetWindowRect(hwndTaskBarMain, &rc);

	//	writeDebugLog_Win10("[tclock.c][InitClock] origWidthMainClock = ", origWidthMainClock);
	//	writeDebugLog_Win10("[tclock.c][InitClock] origHeightMainClock = ", origHeightMainClock);
	//	writeDebugLog_Win10("[tclock.c][InitClock] Main Taskbar Width = ", rc.right - rc.left);
	//	writeDebugLog_Win10("[tclock.c][InitClock] Main Taskbar Height = ", rc.bottom - rc.top);
	//	writeDebugLog_Win10("[tclock.c][InitClock] g_bVertTaskbar = ", g_bVertTaskbar);
	//}


	//ディスプレイ状態確認 Adde by TTTT
	if (bGetDispInfo) checkDisplayStatus_Win10();

	InitAnalogClockData(hwndClockMain);


	GetTimeZoneBias_Win10();




	//サブクラス化
	oldWndProc = (WNDPROC)GetWindowLongPtr(hwndClockMain, GWLP_WNDPROC);
	SubclassWindow(hwndClockMain, WndProc);
	//ダブルクリック受け付けない
	SetClassLongPtr(hwndClockMain, GCL_STYLE,
	  GetClassLongPtr(hwndClockMain, GCL_STYLE) & ~CS_DBLCLKS);


	for (int i = 0; i < numberSubClk; i++) {
		if (bEnableDrawSubClk[i])
		{
			oldWndProcSub[i] = (WNDPROC)GetWindowLongPtr(hwndClockSubClk[i], GWLP_WNDPROC);
			//SubclassWindow(hwndClockSubClk[i], DefWindowProc);
			SubclassWindow(hwndClockSubClk[i], WndProcSubClk);		
		}
	}






	// Added by TTTT for Win10AU (WIN10RS1) compatibility
	if (g_winver&WIN10RS1)
	{
		SetWindowSubclass(hwndTrayMain, SubclassTrayProc,
			SUBCLASSTRAY_ID, (DWORD_PTR)hwnd);
	}
	// End of Insertion by TTTT


	//ツールチップ作成
	TooltipInit(hwndClockMain);

	b = GetMyRegLong("Mouse", "DropFiles", FALSE);
	DragAcceptFiles(hwnd, b);

	//αブレンドのタスクバー設定(?)
	SetLayeredTaskbar(hwndClockMain);

	// hdcClock等ワークエリア作成
//	CreateClockDC();	//描画時にSetMainClockOnTaskTrayが実行されて、作成されるのでコメントアウトした。3.5.0.2
	
	
	//タスクバーの更新
	RedrawMainTaskbar();	//即時反映のために必要。必要があればWindowsのリサイズ処理を通してMainClockの再配置やサイズ更新、hdcClock再作成が実行される。

//	PostMessage(hwndTaskBarMain, WM_SIZE, SIZE_RESTORED, 0);
//	InvalidateRect(hwndTaskBarMain, NULL, TRUE);

	
}

void RedrawTClock(void)
{
	HDC hdc;
	hdc = GetDC(hwndClockMain);
	if (hdc) {
		DrawClock_New(hdc);
		ReleaseDC(hwndClockMain, hdc);
	}
}

void RedrawMainTaskbar(void) 
{
	if (b_DebugLog)writeDebugLog_Win10("[tclock.c] RedrawMainTaskbar called.", 999);
	if (hwndTaskBarMain) 
	{
		PostMessage(hwndTaskBarMain, WM_SIZE, SIZE_RESTORED, 0);
		//	InvalidateRect(hwndTaskBarMain, NULL, TRUE);
	}
}


void ActivateSubClocks(void)
{
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c]ActivateSubClocks called. ", 999);

	//サブディスプレイ上タスクバー時計のフック
	FindAllSubClocks();

	//メインタスクバーの方向をチェック
	g_bVertTaskbar = IsVertTaskbar(hwndTaskBarMain);

	//サブタスクバーはメインとサブが両方横の場合のみ表示する
	for (int i = 0; i < numberSubClk; i++) {
		if (g_bVertTaskbar == IsVertTaskbar(hwndTaskBarSubClk[i])) {
			if (bSubClockFound[i]) bEnableDrawSubClk[i] = TRUE;
		}
		if (b_DebugLog) {
			writeDebugLog_Win10("[tclock.c][ActivateSubClocks] Sub Screen ID = ", i);
			writeDebugLog_Win10("[tclock.c][ActivateSubClocks] bEnableDrawSubClk[i] = ", bEnableDrawSubClk[i]);
		}
	}

	//サブディスプレイ上時計起動時点のサイズを保存
	GetOrigSubClkDimensions();

	//サブディスプレイ上時計のサイズと位置設定
	SetSubClocksOnTaskbars();

	//サブディスプレイ上時計のサブクラス化
	for (int i = 0; i < numberSubClk; i++) {
		if (bEnableDrawSubClk[i])
		{
			oldWndProcSub[i] = (WNDPROC)GetWindowLongPtr(hwndClockSubClk[i], GWLP_WNDPROC);
			//SubclassWindow(hwndClockSubClk[i], DefWindowProc);
			SubclassWindow(hwndClockSubClk[i], WndProcSubClk);
		}
	}


}


/*------------------------------------------------
  ending process
--------------------------------------------------*/
void DeleteClockRes(void)
{
	TooltipDeleteRes();
	if (hFon) DeleteObject(hFon); hFon = NULL;
	if (hdcClock) DeleteDC(hdcClock); hdcClock = NULL;
	if (hbmpClock) DeleteObject(hbmpClock); hbmpClock = NULL;
	if (hbmpClockOld) DeleteObject(hbmpClockOld); hbmpClockOld = NULL;
	if (hbm_DIBSection) DeleteObject(hbm_DIBSection); hbm_DIBSection = NULL;
	if (hdcClock_work) DeleteDC(hdcClock_work); hdcClock_work = NULL;
	if (hbm_DIBSection_work) DeleteObject(hbm_DIBSection_work); hbm_DIBSection_work = NULL;

	if (hpenHour) {
		DeleteObject(hpenHour); hpenHour = NULL;
	}
	if (hpenMin) {
		DeleteObject(hpenMin); hpenMin = NULL;
	}
	if (hdcAnalogClock) {
		DeleteDC(hdcAnalogClock);
		hdcAnalogClock = NULL;
	}
	if (hbmpAnalogClock) {
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
	}
	if (hdcAnalogClockMask) {
		DeleteDC(hdcAnalogClockMask);
		hdcAnalogClockMask = NULL;
	}
	if (hbmpAnalogClockMask) {
		DeleteObject(hbmpAnalogClockMask);
		hbmpAnalogClockMask = NULL;
		lpbyAnalogClockMask = NULL;
	}
}


void EndClock(HWND hwnd)	// Modified by TTTT for Win10AU (WIN10RS1) compatibility
{


	if (!b_CompactMode) {
		newCodes_close_Win10();	//	-> Limited !b_CompactoMode to cope with Win10 April2018 Update
	}


	DragAcceptFiles(hwndClockMain, FALSE);
	TooltipEnd(hwndClockMain);


	DeleteClockRes();
	EndNewAPI(hwndClockMain);
	EndSysres();
	FreeBatteryLife();
	FreeCpuClock();
	CpuMoni_end(); // cpu.c
	PerMoni_end(); // permon.c
	Net_end();     // net.c

	if(hwndClockMain && IsWindow(hwndClockMain))
	{
		if(bTimer) KillTimer(hwndClockMain, IDTIMERDLL_DLLMAIN); bTimer = FALSE;
		if(bTimerSysInfo) KillTimer(hwndClockMain, IDTIMERDLL_SYSINFO);
		//if(bWatchTaskWnd) KillTimer(hwndClockMain, IDTIMERDLL_WATCHTASKWND); bWatchTaskWnd = FALSE;
		//if(checknet) KillTimer(hwndClockMain, IDTIMERDLL_CHECKNET); checknet=FALSE;
		if(bGraphTimerStart) KillTimer(hwndClockMain, IDTIMERDLL_GRAPH); bGraphTimerStart=FALSE;
		if(bTimerCheckNetStat) KillTimer(hwndClockMain, IDTIMERDLL_CHECKNETSTAT); bTimerCheckNetStat = FALSE;
		if(bTooltipTimerStart) KillTimer(hwndClockMain, IDTIMERDLL_TIP); bTooltipTimerStart=FALSE;

		if (hwndClockMain && IsWindow(hwndClockMain))
		{
			if(oldWndProc && (WNDPROC)WndProc == (WNDPROC)GetWindowLongPtr(hwndClockMain, GWLP_WNDPROC))
				SubclassWindow(hwndClockMain, oldWndProc);
		}
		oldWndProc = NULL;

	}

	// Added by TTTT for Win10AU (WIN10RS1) compatibility
	if (g_winver&WIN10RS1)
	{
		RemoveWindowSubclass(hwndTrayMain, SubclassTrayProc,
			SUBCLASSTRAY_ID);
	}
	// End of Insertion by TTTT

//	hwndClockMain = NULL;	//環境によって、2回EndClockされるかもしれないので、
						//クリアしないように。2回目にNULLに対してメッセージを
						//送ってしまい、動作がおかしくなる原因になってるっぽい


	//サブ画面の時計のサブクラス化を解除してタスクバーサイズを戻す。
	DisableAllSubClocks();

	//TClockウィンドウを終了させる
	if(IsWindow(hwndTClockExeMain))
		PostMessage(hwndTClockExeMain, WM_USER+2, 0, 0);
}


/*------------------------------------------------
subclass procedure of the Sub Display clocks , 20211107 TTTT
--------------------------------------------------*/
LRESULT CALLBACK WndProcSubClk(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	//この関数はサブウィンドウの時計(hwndSubClk[i])のプロシージャとして登録しているので、hwndはhwndSubClk[i]のいずれかになる。
	//GetSubClkIndexFromHWNDを使ってiを調べる必要がある。hwndはhwndClockMainではないので注意する。

	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProcSubClk] Window Message was recevied, message = ", message);

	switch (message) {
		case (WM_USER + 100):
			// 親ウィンドウから送られ、サイズを返すメッセージ。
			// (Win10RS1(=AU)以降は)ではメインクロックにもサブクロックにも、サイズ調整が必要な場合には、このメッセージは来ない。
			break;
		//case (WM_NOTIFY):
		case (WM_NCCALCSIZE):
			//サブタスクバーに変更があるとこれが届く、SetSubClocksOnTaskbarsの後にも届くので、これが来たらタスクバーが強制的に
			//戻された、と判断することはできない。デバッグコードにあるような複雑なlparamの中にデータが入っている。
			//rgrc[0]が変更されようとするサイズなので、これがサブクロックのサイズと違えば、Windows標準時計に戻されようとしていることがわかる。
			//その場合はrgrc[0]の値をorigSubClockのサイズとして更新すれば、新しいタスクバーでWindows標準時計サイズがわかる。
			//そのうえで、戻り値に0(容認という意味？)ではなく、WVR _VALIDRECTS(=0x0400)を返したら更新されてしまわずに済む?
			//http://blog.livedoor.jp/oans/archives/50628113.html

			//ここでStoreSpecificSubClockDimensionsを呼んでは行けない。サイズがまだ変更されていないため正しい値を取得することはできない。

		{
			int i, newWidth, newHeight;
			LRESULT ret;
			i = GetSubClkIndexFromHWND(hwnd);
			if ((i != 999) && (bEnableDrawSubClk[i] == TRUE))
			{

				if (g_bVertTaskbar != IsVertTaskbar(hwndTaskBarSubClk[i])) {
					DisableSpecificSubClock(i);
					break;
				}

				NCCALCSIZE_PARAMS* pncsp = (NCCALCSIZE_PARAMS*)lParam;

				if (b_DebugLog) {
					writeDebugLog_Win10("[tclock.c][WndProcSubClk] SubClock index = ", i);
					writeDebugLog_Win10("[tclock.c][WndProcSubClk] wParam = ", wParam);
					writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam = ", (int)lParam);
					for (int j = 0; j < 3; j++) {
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam.rgrc index = ", j);
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam.Rect.left = ", (*pncsp).rgrc[j].left);
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam.Rect.right = ", (*pncsp).rgrc[j].right);
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam.Rect.top = ", (*pncsp).rgrc[j].top);
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] lParam.Rect.bottom = ", (*pncsp).rgrc[j].bottom);
					}
				}

				newWidth = (int)(*pncsp).rgrc[0].right - (int)(*pncsp).rgrc[0].left;
				newHeight = (int)(*pncsp).rgrc[0].bottom - (int)(*pncsp).rgrc[0].top;
				if ((widthSubClock[i] != newWidth) || (heightSubClock[i] != newHeight)) //Clocksize will be changed to original by windows
				{


					origSubClockWidth[i] = newWidth;
					origSubClockHeight[i] = newHeight;

					if (b_DebugLog) {
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] origSubClockWidth updated: ", origSubClockWidth[i]);
						writeDebugLog_Win10("[tclock.c][WndProcSubClk] origSubClockHeight updated: ", origSubClockHeight[i]);
					}

					//新しいタスクバーサイズなどは保存できないが、まあいいか、というところ。


					//以下、新しいタスクバー(ここを呼ぶ前に更新されている)に併せたサブクロックのサイズを計算して送り返すことを試みたが、うまく行かないので
					//ここではWindows標準時計のサイズを獲得できたら十分とする。
					//ただし、実際の画面配置変更は未実行なので、この時点でStoreSpecificSubClockDimensionsとかを実行しても配置は得られない。
					//この直後に届くMW_NCPAINTの段階で取得すればよいか？

					//ret = WVR_VALIDRECTS;

					//CalcSpecificSubClockSize(i);
					//if (g_bVertTaskbarSub) {
					//	(*pncsp).rgrc[0].right = widthSubClock[i];
					//	(*pncsp).rgrc[0].top = (*pncsp).rgrc[0].bottom - heightSubClock[i];

					//	(*pncsp).rgrc[1].right = widthSubClock[i];
					//	(*pncsp).rgrc[2].right = widthSubClock[i];
					//	(*pncsp).rgrc[1].top = (*pncsp).rgrc[1].bottom - heightSubClock[i];
					//	(*pncsp).rgrc[2].top = (*pncsp).rgrc[2].bottom - heightSubClock[i];
					//}
					//else {
					//	(*pncsp).rgrc[0].left = (*pncsp).rgrc[0].right - widthSubClock[i];
					//	(*pncsp).rgrc[0].bottom = heightSubClock[i];

					//	(*pncsp).rgrc[1].left = (*pncsp).rgrc[1].right - widthSubClock[i];
					//	(*pncsp).rgrc[2].left = (*pncsp).rgrc[2].right - widthSubClock[i];
					//	(*pncsp).rgrc[1].bottom = heightSubClock[i];
					//	(*pncsp).rgrc[2].bottom = heightSubClock[i];
				}
			}
		}
	}











	//switch (message) // ツールチップ対応
	//{
	//case WM_MOUSEMOVE:
	//case WM_LBUTTONDOWN:
	//case WM_RBUTTONDOWN:
	//case WM_MBUTTONDOWN:
	//case WM_LBUTTONUP:
	//case WM_RBUTTONUP:
	//case WM_MBUTTONUP:
	//	if (bEnableTooltip)TooltipOnMouseEvent(hwnd, message, wParam, lParam);
	//	if (b_Sleeping)
	//	{
	//		b_Sleeping = FALSE;
	//		if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc] Awake from Sleep by Mouse Action", 999);
	//	}
	//	break;
	//}

	switch (message)
	{
	case WM_SIZE:
//	case WM_WININICHANGE:	//メインクロック側のSubClassTrayProcの処理が波及するので不要
	{
		int i = 0;
		i = GetSubClkIndexFromHWND(hwnd);
		if ((i != 999) && bEnableDrawSubClk[i]) {
			SetSpecificSubClock(i);
		}
		break;
	}
	//// マウスダウン
	//case WM_LBUTTONDOWN:
	//case WM_RBUTTONDOWN:
	//case WM_MBUTTONDOWN:
	//case WM_XBUTTONDOWN:
	//	if (message == WM_RBUTTONDOWN && (wParam & MK_LBUTTON || ((wParam&MK_CONTROL) && (wParam&MK_SHIFT)) || bRClickMenu))
	//	{
	//		return 0;
	//	}
	//	PostMessage(hwndTClockExeMain, message, wParam, lParam);
	//	return 0;
	//	// マウスアップ
	//case WM_LBUTTONUP:
	//case WM_RBUTTONUP:
	//case WM_MBUTTONUP:
	//case WM_XBUTTONUP:
	//	if (message == WM_RBUTTONUP && (wParam & MK_LBUTTON || ((wParam&MK_CONTROL) && (wParam&MK_SHIFT)) || bRClickMenu))
	//	{
	//		DWORD mp;
	//		mp = GetMessagePos();
	//		PostMessage(hwndTClockExeMain, WM_CONTEXTMENU, (WPARAM)hwnd, (LPARAM)mp);
	//		return 0;
	//	}
	//	PostMessage(hwndTClockExeMain, message, wParam, lParam);
	//	//// ↓右クリックがWM_CONTEXTMENUに変換されないようにoldWndProcを呼ばない
	//	//// 呼んでしまうと独自処理を割り当てたときもメニューが開いてしまう
	//	////if(message == WM_RBUTTONUP) break;
	//	return 0;
	//case WM_MOUSEMOVE:
	//	return 0;
	//case WM_CONTEXTMENU:   // 右クリックメニュー
	//					   // ApplicationKeyを押されたときにくる
	//					   // 右クリックの場合は↑で自前で変換しないと､独自処理を割り当てたときも
	//					   // メニューが開いてしまう
	//					   //if (bRClickMenu) {
	//	PostMessage(hwndTClockExeMain, message, wParam, lParam);
	//	//}
	//	return 0;
	//case WM_MOUSEACTIVATE:
	//	return MA_ACTIVATE;
	//	// ファイルのドロップ
	//case WM_DROPFILES:
	//	PostMessage(hwndTClockExeMain, WM_DROPFILES, wParam, lParam);
	//	return 0;
	//case WM_NOTIFY: //ツールチップのテキスト表示
	//{
	//	LRESULT lres;
	//	if (TooltipOnNotify(&lres, lParam)) return lres;
	//	break;
	//}
	//case WM_COMMAND:
	//	if (LOWORD(wParam) == IDC_EXIT)
	//	{
	//		if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] WM_COMMAND with 102(IDC_EXIT) received", 999);
	//		EndClock(hwnd);	// Modified by TTTT for Win10AU (WIN10RS1) compatibility
	//	}
	//	else if (LOWORD(wParam) == IDC_RESTART)
	//	{
	//		if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] WM_COMMAND with IDC_RESTART received", 999);
	//		RestartTClockFromDLL();	// Added by TTTT
	//	}
	//	else if (LOWORD(wParam) == CLOCKM_BGCOLOR_UPDATE)
	//	{

	//	}
	//	else if (!b_CompactMode)
	//	{
	//		if (LOWORD(wParam) == CLOCKM_TOGGLE_AUTOPAUSE_CLOUDAPP) toggleAutoStopCloudApp_Win10();// Added by TTTT	-> Limited !b_CompactoMode to cope with Win10 April2018 Update
	//		if (LOWORD(wParam) == CLOCKM_TOGGLE_DATAPLANFUNC) toggleDataPlanFunc_Win10();// Added by TTTT
	//		if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_VOLUME) toggleBarMeterFunc_Win10(0);// Added by TTTT
	//		if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_CPU) toggleBarMeterFunc_Win10(1);// Added by TTTT
	//		if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_BATTERY) toggleBarMeterFunc_Win10(2);// Added by TTTT
	//		if (LOWORD(wParam) == CLOCKM_DISPLAYSTATUS_CHECK && bGetDispInfo) checkDisplayStatus_Win10();// Added by TTTT
	//	}
	//	return 0;

	//case CLOCKM_VISTACALENDAR:
	//	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc() CLOCKM_VISTACALENDAR received", 999);
	//	{
	//		//hwnd = hwnd, どちらでもOKだった。lParamはマウス座標だが、0でOK
	//		CallWindowProc(oldWndProc, hwnd, WM_LBUTTONDOWN, 0, 0);
	//		CallWindowProc(oldWndProc, hwnd, WM_LBUTTONUP, 0, 0);
	//	}
	//	return 0;

	//case CLOCKM_SHOWAVAILABLENETWORKS:
	//	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc() CLOCKM_SHOWAVAILABLENETWORKS received", 999);
	//	{
	//		ShellExecute(NULL, "open", "ms-availablenetworks:", NULL, NULL, SW_SHOWNORMAL);
	//	}
	//	return 0;

	//case CLOCKM_SHOWPROFILELIST:
	//	saveAndOpenProfTable(TRUE);
	//	return 0;

	//case WM_WINDOWPOSCHANGING:  // サイズ調整
	//							//if (g_winver&WIN10RS1) break;	//Added by TTTT for Win10AU

	//							//Modifed 20191207 TTTT 2271 based on TClockLight-kt280904

	//							//			OnWindowPosChanging(hwnd, (LPWINDOWPOS)lParam);		// Unclear whether it is needed or not

	//	break;

	}












	return DefWindowProc(hwnd, message, wParam, lParam);
}

/*------------------------------------------------
  subclass procedure of the clock
--------------------------------------------------*/
LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND tempHwnd;
	tempHwnd = hwnd;
	//このコールバック関数はhwndClockMainとの組み合わせででしか正しく動作しないので、原則としてhwnd = hwndClockMainだがコールバック関数なのでtempHwndで処理している
	//messageは、定常運転時はWM_TIMER(275)以外はめったに来ない。
	if (b_DebugLog) {
			//3:	WM_MOVE
			//5:	WM_SIZE
			//15:	WM_PAINT
			//20:	WM_PAINT
			//32:	WM_SETCURSOR
			//70:	WM_WINDOWPOSCHANGING 
			//71:	WM_WINDOWPOSCHANGED
			//78: 	WM_NOTIFY 
			//85:	WM_NOTIFYFORMAT
			//124: 	WM_STYLECHANGING
			//125: 	WM_STYLECHANGED
			//131:	WM_NCCALCSIZE 
			//133:  WM_NCPAINT
			//512:	WM_MOUSEFIRST, WM_MOUSEMOVE
			//792: 	WM_PRINTCLIENT
			//1028:
			//1124: USER + 100
			writeDebugLog_Win10("[tclock.c][WndProc] Window Message was recevied, message = ", message);
	}


	switch(message) // ツールチップ対応
	{
		case WM_MOUSEMOVE:
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		case WM_MBUTTONUP:
			if (bEnableTooltip)TooltipOnMouseEvent(tempHwnd, message, wParam, lParam);
			if (b_Sleeping)
			{
				b_Sleeping = FALSE;
				if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc] Awake from Sleep by Mouse Action", 999);
			}
			break;
	}

	switch(message)
	{
		case WM_DESTROY:
			DeleteClockRes();
			break;
		case (WM_USER + 100):
			// 親ウィンドウから送られ、サイズを返すメッセージ。
			// Win10RS1(=AU)では、メインクロックではタスクトレイがこのメッセージを受けて対応する(SubClassTrayProc)ので、何もしなくて良い。
			// LRESULT形式でLOWORD=時計高さ、HIWORD=時計幅を返答すると場所が確保される。

			//if (g_winver&WIN10RS1) 
			break;

		// システムの設定を反映する
		case WM_SYSCOLORCHANGE:
		case WM_WININICHANGE:
		case WM_TIMECHANGE:	
		case (WM_USER+101):		// 親ウィンドウから送られる
		{
			RedrawTClock();
			return 0;
		}
		case WM_SIZE:
			break;
		case WM_ERASEBKGND:
			break;
		case WM_SETFOCUS:
			bGetingFocus = TRUE;
			break;
		case WM_KILLFOCUS:
			bGetingFocus = FALSE;
			break;
		case WM_PAINT:
		{
			//RedrawTClockと処理は同じだがWM_PAINTに対してはGetDC->BeginPaintとかにする必要があるらしい
			PAINTSTRUCT ps;
			HDC hdc;
			hdc = BeginPaint(tempHwnd, &ps);
			DrawClock_New(hdc);
			EndPaint(tempHwnd, &ps);
			return 0;
		}
		case WM_TIMER:
			//if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc() WM_TIMER received with ID: ", (int)wParam);
			if (!b_Sleeping)
			{
				if (wParam == IDTIMERDLL_DLLMAIN)
				{
					OnTimer_Win10();
				}
				else if (wParam == IDTIMERDLL_SYSINFO)
				{
					UpdateSysRes(bGetSysRes, bGetBattery, bGetMem, bGetMb, bGetPm, bGetNet, bGetHdd, bGetCpu, bGetVol);
				}
				else if (wParam == IDTIMERDLL_CHECKNETSTAT)
				{
					OntimerCheckNetStat_Win10(tempHwnd);
				}
				//else if (wParam == IDTIMERDLL_WATCHTASKWND) {
				//	OnTimerUpperTaskbar();
				//}
				else if (wParam == IDTIMERDLL_TIP) {
					TooltipOnTimer(tempHwnd);
				}
			}
			else if (wParam == IDTIMERDLL_DLLMAIN)
			{
				if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc] WM_TIMER actions cancelled because b_Sleeping = TRUE", 999);
			}
			return 0;
		// マウスダウン
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_XBUTTONDOWN:
			if (message == WM_RBUTTONDOWN && (wParam & MK_LBUTTON || ((wParam&MK_CONTROL)&&(wParam&MK_SHIFT)) || bRClickMenu))
			{
				return 0;
			}
			PostMessage(hwndTClockExeMain, message, wParam, lParam);
			return 0;
		// マウスアップ
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		case WM_MBUTTONUP:
		case WM_XBUTTONUP:
			if (message == WM_RBUTTONUP && (wParam & MK_LBUTTON || ((wParam&MK_CONTROL)&&(wParam&MK_SHIFT)) || bRClickMenu))
			{
				DWORD mp;
				mp = GetMessagePos();
				PostMessage(hwndTClockExeMain, WM_CONTEXTMENU, (WPARAM)tempHwnd, (LPARAM)mp);
				return 0;
			}
			PostMessage(hwndTClockExeMain, message, wParam, lParam);
			//// ↓右クリックがWM_CONTEXTMENUに変換されないようにoldWndProcを呼ばない
			//// 呼んでしまうと独自処理を割り当てたときもメニューが開いてしまう
			////if(message == WM_RBUTTONUP) break;
			return 0;
		case WM_MOUSEMOVE:
			return 0;
		case WM_CONTEXTMENU:   // 右クリックメニュー
			// ApplicationKeyを押されたときにくる
			// 右クリックの場合は↑で自前で変換しないと､独自処理を割り当てたときも
			// メニューが開いてしまう
			//if (bRClickMenu) {
				PostMessage(hwndTClockExeMain, message, wParam, lParam);
			//}
			return 0;
		case WM_NCHITTEST: // oldWndProcに処理させない
			return DefWindowProc(tempHwnd, message, wParam, lParam);
		case WM_MOUSEACTIVATE:
			return MA_ACTIVATE;
		// ファイルのドロップ
		case WM_DROPFILES:
			PostMessage(hwndTClockExeMain, WM_DROPFILES, wParam, lParam);
			return 0;
		case WM_NOTIFY: //ツールチップのテキスト表示
		{
			LRESULT lres;
			if (TooltipOnNotify(&lres, lParam)) return lres;
			break;
		}
		case WM_COMMAND:
			if (LOWORD(wParam) == IDC_EXIT) 
			{
				if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] WM_COMMAND with 102(IDC_EXIT) received", 999);
				EndClock(tempHwnd);	// Modified by TTTT for Win10AU (WIN10RS1) compatibility
			}
			else if (LOWORD(wParam) == IDC_RESTART)
			{
				if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] WM_COMMAND with IDC_RESTART received", 999);
				RestartTClockFromDLL();	// Added by TTTT
			}
			else if (LOWORD(wParam) == CLOCKM_BGCOLOR_UPDATE)
			{

			}
			else if (!b_CompactMode)
			{
				if (LOWORD(wParam) == CLOCKM_TOGGLE_AUTOPAUSE_CLOUDAPP) toggleAutoStopCloudApp_Win10();// Added by TTTT	-> Limited !b_CompactoMode to cope with Win10 April2018 Update
				if (LOWORD(wParam) == CLOCKM_TOGGLE_DATAPLANFUNC) toggleDataPlanFunc_Win10();// Added by TTTT
				if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_VOLUME) toggleBarMeterFunc_Win10(0);// Added by TTTT
				if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_CPU) toggleBarMeterFunc_Win10(1);// Added by TTTT
				if (LOWORD(wParam) == CLOCKM_TOGGLE_BARMETER_BATTERY) toggleBarMeterFunc_Win10(2);// Added by TTTT
				if (LOWORD(wParam) == CLOCKM_DISPLAYSTATUS_CHECK && bGetDispInfo) checkDisplayStatus_Win10();// Added by TTTT
			}
			return 0;

		case CLOCKM_SLEEP_IN:
			if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] CLOCKM_SLEEP_IN received", 999);
			if (b_ModernStandbySupported) b_Sleeping = TRUE;
			return 0;

		case CLOCKM_SLEEP_AWAKE:
			if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc()] CLOCKM_SLEEP_AWAKE received", 999);
			b_Sleeping = FALSE;
			return 0;

		case CLOCKM_REFRESHCLOCK: // refresh the clock
		{
			BOOL tempBool;
			b_ImmediateUsageUpdate = TRUE;

			tempBool = bEnableSubClks;

			ReadData();

			if (!tempBool && bEnableSubClks) {
				ActivateSubClocks();
			}
			else if (tempBool && !bEnableSubClks) {
				DisableAllSubClocks();
			}

			InitAnalogClockData(tempHwnd);

			tempBool = GetMyRegLong("Mouse", "DropFiles", FALSE);
			DragAcceptFiles(tempHwnd, tempBool);

			RedrawTClock();

			TooltipOnRefresh(tempHwnd);
		}
		return 0;
		case CLOCKM_VISTACALENDAR:
			if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc() CLOCKM_VISTACALENDAR received", 999);
			{
				//tempHwnd = tempHwnd, どちらでもOKだった。lParamはマウス座標だが、0でOK
				CallWindowProc(oldWndProc, tempHwnd, WM_LBUTTONDOWN, 0, 0);
				CallWindowProc(oldWndProc, tempHwnd, WM_LBUTTONUP, 0, 0);
			}
			return 0;

		case CLOCKM_SHOWAVAILABLENETWORKS:
			if (b_DebugLog) writeDebugLog_Win10("[tclock.c][WndProc() CLOCKM_SHOWAVAILABLENETWORKS received", 999);
			{
				ShellExecute(NULL, "open", "ms-availablenetworks:", NULL, NULL, SW_SHOWNORMAL);
			}
			return 0;

		case CLOCKM_SHOWPROFILELIST:
			saveAndOpenProfTable(TRUE);
			return 0;

		case CLOCKM_REFRESHTASKBAR: // refresh other elements than clock

			SetLayeredTaskbar(tempHwnd);
			RedrawMainTaskbar();	//即時反映のために必要。必要があればWindowsのリサイズ処理を通してMainClockの再配置やサイズ更新、hdcClock再作成が実行される。

			return 0;
		case WM_WINDOWPOSCHANGING:  // サイズ調整
			//if (g_winver&WIN10RS1) break;	//Added by TTTT for Win10AU
			//Modifed 20191207 TTTT 2271 based on TClockLight-kt280904
//			OnWindowPosChanging(tempHwnd, (LPWINDOWPOS)lParam);		// Unclear whether it is needed or not

			break;

	}
	return CallWindowProc(oldWndProc, tempHwnd, message, wParam, lParam);
}



/*------------------------------------------------
　設定の読み込みとデータの初期化
--------------------------------------------------*/
void ReadData()
{
	char fontname[80];
	char strTemp[128];
	int fontsize;
	LONG weight, italic;
	SYSTEMTIME lt;
	DWORD dwInfoFormat;
	int resnetinterval;

	extern BOOL b_exist_DOWzone;
	b_exist_DOWzone = FALSE;



	//Added by TTTT

	b_DebugLog = GetMyRegLong(NULL, "DebugLog", FALSE);
	SetMyRegLong(NULL, "DebugLog", b_DebugLog);

	b_NormalLog = GetMyRegLong(NULL, "NormalLog", TRUE);

	b_DebugLog_RegAccess = GetMyRegLong(NULL, "DebugLog_RegAccess", FALSE);
	b_DebugLog_Specific = GetMyRegLong(NULL, "DebugLog_Specific", FALSE);


	b_WarnDelayedUsageRetrieval = GetMyRegLong(NULL, "WarnDelayedUsageRetrieval", TRUE);
	SetMyRegLong(NULL, "WarnDelayedUsageRetrieval", b_WarnDelayedUsageRetrieval);

	b_AutoClearLogFile = GetMyRegLong(NULL, "AutoClearLogFile", TRUE);
	SetMyRegLong(NULL, "AutoClearLogFile", b_AutoClearLogFile);

	AutoClearLogLines = GetMyRegLong(NULL, "AutoClearLogLines", 1000);
	if (AutoClearLogLines < 100) AutoClearLogLines = 100;
	SetMyRegLong(NULL, "AutoClearLogLines", AutoClearLogLines);

	b_English = GetMyRegLong(NULL, "EnglishMenu", FALSE);



	bEnableSubClks = GetMyRegLong(NULL, "EnableOnSubDisplay", TRUE);
	SetMyRegLong(NULL, "EnableOnSubDisplay", bEnableSubClks);

	//LogLineCount = AutoClearLogLines;
	LogLineCount = 0;

	GetMyRegStr("Status_DoNotEdit", "Version", Ver_TClockWin10, 16, "Not Available");

	b_ExistLTEProfile = GetMyRegLong("Status_DoNotEdit", "ExistLTEProfile", FALSE);

	b_ExistMeteredProfile = GetMyRegLong("Status_DoNotEdit", "ExistMeteredProfile", FALSE);

	//モダンスタンバイ対応確認
	b_ModernStandbySupported = CheckModernStandbyCapability_Win10();
	SetMyRegLong("Status_DoNotEdit", "ModernStandbySupported", b_ModernStandbySupported);

	//設定番号取得


	colfore = GetMyRegLong("Color_Font", "ForeColor",
		0x80000000 | COLOR_BTNTEXT);
	ColorWeekdayText = colfore;



	colback = GetMyRegLong("Color_Font", "BackColor",
		0x80000000 | COLOR_3DFACE);
	if(GetMyRegLong("Color_Font", "UseBackColor2", FALSE))
		colback2 = GetMyRegLong("Color_Font", "BackColor2", colback);
	else colback2 = colback;

	{
		fillbackcolor = GetMyRegLong("Color_Font", "UseBackColor", TRUE);
	}
	grad = GetMyRegLong("Color_Font", "GradDir", GRADIENT_FILL_RECT_H);

	bClockShadow = GetMyRegLong("Color_Font", "ForeColorShadow", FALSE);
	bClockBorder = GetMyRegLong("Color_Font", "ForeColorBorder", FALSE);
	colShadow = GetMyRegLong("Color_Font", "ShadowColor", RGB(0, 0, 0));
	nShadowRange = (int)(short)GetMyRegLong("Color_Font", "ClockShadowRange", 1);

	bRClickMenu = GetMyRegLong("Mouse", "RightClickMenu", TRUE);

	GetMyRegStr("Color_Font", "Font", fontname, 80, "");

	fontsize = GetMyRegLong("Color_Font", "FontSize", 9);
	weight = GetMyRegLong("Color_Font", "Bold", 0);
	if(weight) weight = FW_BOLD;
	else weight = 0;
	italic = GetMyRegLong("Color_Font", "Italic", 0);

	//if(hFon) DeleteObject(hFon);	//ここで明示的にDeleteするなら、CreateMyFontの後でSetTClockFontを実行する必要がある。
	
	hFon = CreateMyFont(fontname, fontsize, weight, italic);

	//SetTClockFont();

	TooltipReadData();
	if (bTooltipTimerStart) KillTimer(hwndClockMain, IDTIMERDLL_TIP); bTooltipTimerStart = FALSE;


	if (bEnableTooltip) {
		bTooltipTimerStart = SetTimer(hwndClockMain, IDTIMERDLL_TIP, 200, NULL) != 0;
	}

	nTextPos = GetMyRegLong("Color_Font", "TextPos", 0);

	dwidth = (int)(short)GetMyRegLong("Color_Font", "ClockWidth", 0);
	dvpos = (int)(short)GetMyRegLong("Color_Font", "VertPos", 0);
	dlineheight = (int)(short)GetMyRegLong("Color_Font", "LineHeight", 0);

	ColorSaturdayText = (COLORREF)GetMyRegLong("Color_Font", "Saturday_TextColor", 0x1000000);
	SetMyRegLong("Color_Font", "Saturday_TextColor", ColorSaturdayText);
	ColorSundayText = (COLORREF)GetMyRegLong("Color_Font", "Sunday_TextColor", 0x1000000);
	SetMyRegLong("Color_Font", "Sunday_TextColor", ColorSundayText);
	ColorHolidayText = (COLORREF)GetMyRegLong("Color_Font", "Holiday_TextColor", 0x1000000);
	SetMyRegLong("Color_Font", "Holiday_TextColor", ColorHolidayText);
	ColorVPNText = (COLORREF)GetMyRegLong("Color_Font", "VPN_TextColor", 0x1000000);
	SetMyRegLong("Color_Font", "VPN_TextColor", ColorVPNText);






	bGraph = GetMyRegLong("Graph", "BackNet", FALSE);
	SetMyRegLong("Graph", "BackNet", bGraph);

	bLogGraph = GetMyRegLong("Graph", "LogGraph", FALSE);
	bReverseGraph = GetMyRegLong("Graph", "ReverseGraph", FALSE);
	bGraphTate = GetMyRegLong("Graph", "GraphTate", FALSE);
	NetGraphScaleRecv = GetMyRegLong("Graph", "NetGraphScaleRecv", 100);
	NetGraphScaleSend = GetMyRegLong("Graph", "NetGraphScaleSend", 100);
	ColSend = GetMyRegLong("Graph", "BackNetColSend", 0x000000ff);
	ColRecv = GetMyRegLong("Graph", "BackNetColRecv", 0x00ff0000);
	ColSR = GetMyRegLong("Graph", "BackNetColSR", 0x00800080);

	graphInterval = 1;
	graphMode = GetMyRegLong("Graph", "GraphMode", 1);
	cpuHigh = GetMyRegLong("Graph", "CpuHigh", 70);
	GraphL = GetMyRegLong("Graph", "GraphLeft", 0);
	GraphT = GetMyRegLong("Graph", "GraphTop", 0);
	GraphR = GetMyRegLong("Graph", "GraphRight", 1);
	GraphB = GetMyRegLong("Graph", "GraphBottom", 1);
	GraphType = GetMyRegLong("Graph", "GraphType", 1);

	if (bLogGraph)
	{
		if (NetGraphScaleRecv > 9) LogDigit = log10(NetGraphScaleRecv) + 1;
		if (NetGraphScaleSend > 9) LogDigit2 = log10(NetGraphScaleSend) + 1;
	}




	//DataPlan Settings added by TTTT, Moved to findDataPlanProfile_Win10()
	b_UseDataPlanFunction = GetMyRegLong("DataPlan", "UseDataPlanFunction", FALSE);
	SetMyRegLong("DataPlan", "UseDataPlanFunction", b_UseDataPlanFunction);

	b_EnableStopCloudApp = GetMyRegLong("AppControl", "EnableStopAppOnMeteredNet", FALSE);
	SetMyRegLong("AppControl", "EnableStopAppOnMeteredNet", b_EnableStopCloudApp);



	b_dataPlanFixedDayInMonth = GetMyRegLong("DataPlan", "DataPlanFixedDayInMonth", FALSE);
	SetMyRegLong("DataPlan", "DataPlanFixedDayInMonth", b_dataPlanFixedDayInMonth);

	dataPlanContractYear = GetMyRegLong("DataPlan", "DataPlanContractYear", 2018);
	SetMyRegLong("DataPlan", "DataPlanContractYear", dataPlanContractYear);

	dataPlanContractMonth = GetMyRegLong("DataPlan", "DataPlanContractMonth", 1);
	SetMyRegLong("DataPlan", "DataPlanContractMonth", dataPlanContractMonth);

	dataPlanContractDay = GetMyRegLong("DataPlan", "DataPlanContractDay", 1);
	SetMyRegLong("DataPlan", "DataPlanContractDay", dataPlanContractDay);

	dataPlanLimitInMegabyte = GetMyRegLong("DataPlan", "DataPlanLimitInMegabyte", 5000);
	SetMyRegLong("DataPlan", "DataPlanLimitInMegabyte", dataPlanLimitInMegabyte);

	dataPlanLimitDays = GetMyRegLong("DataPlan", "DataPlanLimitDays", 360);
	SetMyRegLong("DataPlan", "DataPlanLimitDays", dataPlanLimitDays);
	
	dataPlanBillingPeriodDays = GetMyRegLong("DataPlan", "DataPlanPeriodDays", 30);
	SetMyRegLong("DataPlan", "DataPlanPeriodDays", dataPlanBillingPeriodDays);


	DataPlanUsageRetrieveMode = (int)GetMyRegLong("DataPlan", "DataPlanUsageRetrieveMode", 0);
	SetMyRegLong("DataPlan", "DataPlanUsageRetrieveMode", DataPlanUsageRetrieveMode);

	specifiedRetrieveProfNum = GetMyRegLong("DataPlan", "SpecifiedMeteredProfileNumber", 0);
	SetMyRegLong("DataPlan", "SpecifiedMeteredProfileNumber", specifiedRetrieveProfNum);

	previousLTEProfNum = GetMyRegLong("Status_DoNotEdit", "PreviousLTEProfNumber", 0);
	SetMyRegLong("Status_DoNotEdit", "PreviousLTEProfNumber", previousLTEProfNum);

	GetMyRegStr("Status_DoNotEdit", "PreviousLTEProfName", previousLTEProfName, 256, "");
	SetMyRegStr("Status_DoNotEdit", "PreviousLTEProfName", previousLTEProfName);

	digitDataPlanInGB = GetMyRegLong("DataPlan", "DigitDataPlanInGB", 3);
	SetMyRegLong("DataPlan", "DigitDataPlanInGB", digitDataPlanInGB);

	megabytesInGigaByte = GetMyRegLong("DataPlan", "MegabytesInGigaByte", 1000);
	if (megabytesInGigaByte != 1024) megabytesInGigaByte = 1000;
	SetMyRegLong("DataPlan", "MegabytesInGigaByte", megabytesInGigaByte);
	
	b_BlinkDataUsage = GetMyRegLong("DataPlan", "BlinkInRetrieval", FALSE);
	SetMyRegLong("DataPlan", "BlinkInRetrieval", b_BlinkDataUsage);

	GetModuleFileName(hmod, g_mydir_dll, MAX_PATH);		//iniファイル経由でなくディレクトリ取得するように by TTTT
	del_title(g_mydir_dll);



	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] ReadData called.", 999);


	dataPlanChkPeriod_Win10 = GetMyRegLong("DataPlan", "ConnectionStatusCheckPeriod", 30);
	if (dataPlanChkPeriod_Win10 < 9) dataPlanChkPeriod_Win10 = 10;
	if (dataPlanChkPeriod_Win10 > 300) dataPlanChkPeriod_Win10 = 300;
	SetMyRegLong("DataPlan", "ConnectionStatusCheckPeriod", dataPlanChkPeriod_Win10);




	GetMyRegStr("AppControl", "ControlledAppExe1", strCloudExe1, MAX_PATH, "");
	SetMyRegStr("AppControl", "ControlledAppExe1", strCloudExe1);

	GetMyRegStr("AppControl", "ControlledAppExe2", strCloudExe2, MAX_PATH, "");
	SetMyRegStr("AppControl", "ControlledAppExe2", strCloudExe2);

	GetMyRegStr("AppControl", "ControlledAppExe3", strCloudExe3, MAX_PATH, "");
	SetMyRegStr("AppControl", "ControlledAppExe3", strCloudExe3);

	GetMyRegStr("AppControl", "ControlledAppExe4", strCloudExe4, MAX_PATH, "");
	SetMyRegStr("AppControl", "ControlledAppExe4", strCloudExe4);

	GetMyRegStr("AppControl", "ControlledAppExe5", strCloudExe5, MAX_PATH, "");
	SetMyRegStr("AppControl", "ControlledAppExe5", strCloudExe5);

	

	GetMyRegStr("VPN", "SoftEtherKeyword", strSoftEtherKeyword, 32, "VPN Client Adapter");
	SetMyRegStr("VPN", "SoftEtherKeyword", strSoftEtherKeyword);



	GetMyRegStr("VPN", "VPN_Keyword1", strVPN_Keyword1, 32, "");
	SetMyRegStr("VPN", "VPN_Keyword1", strVPN_Keyword1);
	if (strlen(strVPN_Keyword1) == 0) strcpy(strVPN_Keyword1, "VPN Adapter Keyword1");

	GetMyRegStr("VPN", "VPN_Keyword2", strVPN_Keyword2, 32, "");
	SetMyRegStr("VPN", "VPN_Keyword2", strVPN_Keyword2);
	if (strlen(strVPN_Keyword2) == 0) strcpy(strVPN_Keyword2, "VPN Adapter Keyword2");


	GetMyRegStr("VPN", "VPN_Keyword3", strVPN_Keyword3, 32, "");
	SetMyRegStr("VPN", "VPN_Keyword3", strVPN_Keyword3);
	if (strlen(strVPN_Keyword3) == 0) strcpy(strVPN_Keyword3, "VPN Adapter Keyword3");

	GetMyRegStr("VPN", "VPN_Keyword4", strVPN_Keyword4, 32, "");
	SetMyRegStr("VPN", "VPN_Keyword4", strVPN_Keyword4);
	if (strlen(strVPN_Keyword4) == 0) strcpy(strVPN_Keyword4, "VPN Adapter Keyword4");

	GetMyRegStr("VPN", "VPN_Keyword5", strVPN_Keyword5, 32, "");
	SetMyRegStr("VPN", "VPN_Keyword5", strVPN_Keyword5);
	if (strlen(strVPN_Keyword5) == 0) strcpy(strVPN_Keyword5, "VPN Adapter Keyword5");

	GetMyRegStr("VPN", "VPN_Exclude1", strVPN_Exclude1, 32, "");
	SetMyRegStr("VPN", "VPN_Exclude1", strVPN_Exclude1);
	if (strlen(strVPN_Exclude1) == 0) strcpy(strVPN_Exclude1, "VPN Adapter Exclude1");

	GetMyRegStr("VPN", "VPN_Exclude2", strVPN_Exclude2, 32, "");
	SetMyRegStr("VPN", "VPN_Exclude2", strVPN_Exclude2);
	if (strlen(strVPN_Exclude2) == 0) strcpy(strVPN_Exclude2, "VPN Adapter Exclude2");


	GetMyRegStr("VPN", "VPN_Exclude3", strVPN_Exclude3, 32, "");
	SetMyRegStr("VPN", "VPN_Exclude3", strVPN_Exclude3);
	if (strlen(strVPN_Exclude3) == 0) strcpy(strVPN_Exclude3, "VPN Adapter Exclude3");

	GetMyRegStr("VPN", "VPN_Exclude4", strVPN_Exclude4, 32, "");
	SetMyRegStr("VPN", "VPN_Exclude4", strVPN_Exclude4);
	if (strlen(strVPN_Exclude4) == 0) strcpy(strVPN_Exclude4, "VPN Adapter Exclude4");

	GetMyRegStr("VPN", "VPN_Exclude5", strVPN_Exclude5, 32, "");
	SetMyRegStr("VPN", "VPN_Exclude5", strVPN_Exclude5);
	if (strlen(strVPN_Exclude5) == 0) strcpy(strVPN_Exclude5, "VPN Adapter Exclude5");





	GetMyRegStr("ETC", "Ethernet_Keyword1", strEthernet_Keyword1, 32, "");
	SetMyRegStr("ETC", "Ethernet_Keyword1", strEthernet_Keyword1);
	if (strlen(strEthernet_Keyword1) == 0) strcpy(strEthernet_Keyword1, "Ethernet Adapter Keyword1");

	GetMyRegStr("ETC", "Ethernet_Keyword2", strEthernet_Keyword2, 32, "");
	SetMyRegStr("ETC", "Ethernet_Keyword2", strEthernet_Keyword2);
	if (strlen(strEthernet_Keyword2) == 0) strcpy(strEthernet_Keyword2, "Ethernet Adapter Keyword2");

	GetMyRegStr("ETC", "Ethernet_Keyword3", strEthernet_Keyword3, 32, "");
	SetMyRegStr("ETC", "Ethernet_Keyword3", strEthernet_Keyword3);
	if (strlen(strEthernet_Keyword3) == 0) strcpy(strEthernet_Keyword3, "Ethernet Adapter Keyword3");

	GetMyRegStr("ETC", "Ethernet_Keyword4", strEthernet_Keyword4, 32, "");
	SetMyRegStr("ETC", "Ethernet_Keyword4", strEthernet_Keyword4);
	if (strlen(strEthernet_Keyword4) == 0) strcpy(strEthernet_Keyword4, "Ethernet Adapter Keyword4");

	GetMyRegStr("ETC", "Ethernet_Keyword5", strEthernet_Keyword5, 32, "");
	SetMyRegStr("ETC", "Ethernet_Keyword5", strEthernet_Keyword5);
	if (strlen(strEthernet_Keyword5) == 0) strcpy(strEthernet_Keyword5, "Ethernet Adapter Keyword5");

	if (!(g_winver&WIN10RS1))
	{
		b_UseDataPlanFunction = FALSE;
		b_EnableStopCloudApp = FALSE;
	}


	//CompactMode Added by TTTT
	b_CompactMode = GetMyRegLong(NULL, "CompactMode", TRUE);
	SetMyRegLong(NULL, "CompactMode", b_CompactMode);


	//SafeMode operation Added by TTTT
	b_SafeMode = GetMyRegLong("Status_DoNotEdit", "SafeMode", FALSE);
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][ReadData] b_SafeMode was retrieved from tclock-win10.ini as ", b_SafeMode);

	if (b_SafeMode)
	{
		b_CompactMode = TRUE;
		b_UseDataPlanFunction = FALSE;
		b_EnableStopCloudApp = FALSE;
	}

	GetMyRegStr("ETC", "LTEString", strLTE, 32, "LTE");
	if (strlen(strLTE) == 0) strcpy(strLTE, "LTE");
	SetMyRegStr("ETC", "LTEString", strLTE);

	GetMyRegStr("ETC", "LTEChar", strBuf, 32, "L");
	if (strlen(strBuf) == 0)
	{
		strcpy(charLTE, "L");
	}
	else
	{
		strncpy(charLTE, strBuf, 1);
	}
	SetMyRegStr("ETC", "LTEChar", charLTE);


	GetMyRegStr("ETC", "MuteString", strMute, 32, "*");
	if (strlen(strMute) == 0) strcpy(strMute, "*");
	SetMyRegStr("ETC", "MuteString", strMute);




	int BarMeterWidth;
	int BarMeterHeight;
	int BarMeterSpacing;

	
	b_BarMeterVL_Horizontal = GetMyRegLong("BarMeter", "BarMeterVL_Horizontal", FALSE);
	SetMyRegLong("BarMeter", "BarMeterVL_Horizontal", b_BarMeterVL_Horizontal);

	b_BarMeterBL_Horizontal = GetMyRegLong("BarMeter", "BarMeterBL_Horizontal", FALSE);
	SetMyRegLong("BarMeter", "BarMeterBL_Horizontal", b_BarMeterBL_Horizontal);
	
	b_BarMeterCU_Horizontal = GetMyRegLong("BarMeter", "BarMeterCU_Horizontal", FALSE);
	SetMyRegLong("BarMeter", "BarMeterCU_Horizontal", b_BarMeterCU_Horizontal);
	
	b_BarMeterNet_Horizontal = GetMyRegLong("BarMeter", "BarMeterNet_Horizontal", FALSE);
	SetMyRegLong("BarMeter", "BarMeterNet_Horizontal", b_BarMeterNet_Horizontal);



	b_UseBarMeterVL = GetMyRegLong("BarMeter", "UseBarMeterVL", 0);
	SetMyRegLong("BarMeter", "UseBarMeterVL", b_UseBarMeterVL);


	ColorBarMeterVL = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterVL", RGB(0, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterVL", ColorBarMeterVL);

	ColorBarMeterVL_Mute = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterVL_Mute", RGB(255, 0, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterVL_Mute", ColorBarMeterVL_Mute);


	BarMeterVL_Right = (int)(short)GetMyRegLong("BarMeter", "BarMeterVL_Right", 290);
	SetMyRegLong("BarMeter", "BarMeterVL_Right", BarMeterVL_Right);

	BarMeterWidth = (int)(short)GetMyRegLong("BarMeter", "BarMeterVL_Width", 5);
	if (BarMeterWidth <= 0) BarMeterWidth = 5;
	BarMeterVL_Left = BarMeterVL_Right + BarMeterWidth;
	SetMyRegLong("BarMeter", "BarMeterVL_Width", BarMeterWidth);

	BarMeterVL_Bottom = (int)(short)GetMyRegLong("BarMeter", "BarMeterVL_Bottom", 0);
	if (BarMeterVL_Bottom < 0) BarMeterVL_Bottom = 0;
	SetMyRegLong("BarMeter", "BarMeterVL_Bottom", BarMeterVL_Bottom);

	BarMeterHeight = (int)(short)GetMyRegLong("BarMeter", "BarMeterVL_Height", -1);
	if (BarMeterHeight <= 0) BarMeterHeight = -1;
	if (BarMeterHeight == -1)
		BarMeterVL_Top = -1;
	else
		BarMeterVL_Top = BarMeterVL_Bottom + BarMeterHeight;
	SetMyRegLong("BarMeter", "BarMeterVL_Height", BarMeterHeight);





	b_UseBarMeterBL = GetMyRegLong("BarMeter", "UseBarMeterBL", 0);
	SetMyRegLong("BarMeter", "UseBarMeterBL", b_UseBarMeterBL);


	ColorBarMeterBL_Charge = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterBL_Charge", RGB(255, 165, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterBL_Charge", ColorBarMeterBL_Charge);

	ColorBarMeterBL_High = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterBL_High", RGB(0, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterBL_High", ColorBarMeterBL_High);

	ColorBarMeterBL_Mid = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterBL_Mid", RGB(255, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterBL_Mid", ColorBarMeterBL_Mid);

	ColorBarMeterBL_Low = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterBL_Low", RGB(255, 0, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterBL_Low", ColorBarMeterBL_Low);

	BarMeterBL_Right = (int)(short)GetMyRegLong("BarMeter", "BarMeterBL_Right", 210);
	SetMyRegLong("BarMeter", "BarMeterBL_Right", BarMeterBL_Right);	
	
	BarMeterWidth = (int)(short)GetMyRegLong("BarMeter", "BarMeterBL_Width", 5);
	if (BarMeterWidth <= 0) BarMeterWidth = 5;
	BarMeterBL_Left = BarMeterBL_Right + BarMeterWidth;
	SetMyRegLong("BarMeter", "BarMeterBL_Width", BarMeterWidth);


	BarMeterBL_Bottom = (int)(short)GetMyRegLong("BarMeter", "BarMeterBL_Bottom", 0);
	if (BarMeterBL_Bottom < 0) BarMeterBL_Bottom = 0;
	SetMyRegLong("BarMeter", "BarMeterBL_Bottom", BarMeterBL_Bottom);

	BarMeterHeight = (int)(short)GetMyRegLong("BarMeter", "BarMeterBL_Height", -1);
	if (BarMeterHeight <= 0) BarMeterHeight = -1;
	if (BarMeterHeight == -1)
		BarMeterBL_Top = -1 ;
	else
		BarMeterBL_Top = BarMeterBL_Bottom + BarMeterHeight;
	SetMyRegLong("BarMeter", "BarMeterBL_Height", BarMeterHeight);


	b_UseBarMeterCU = GetMyRegLong("BarMeter", "UseBarMeterCU", 0);
	SetMyRegLong("BarMeter", "UseBarMeterCU", b_UseBarMeterCU);

	ColorBarMeterCU_High = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCU_High", RGB(255, 0, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCU_High", ColorBarMeterCU_High);

	ColorBarMeterCU_Mid = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCU_Mid", RGB(255, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCU_Mid", ColorBarMeterCU_Mid);

	ColorBarMeterCU_Low = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCU_Low", RGB(0, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCU_Low", ColorBarMeterCU_Low);


	BarMeterCU_Right = (int)(short)GetMyRegLong("BarMeter", "BarMeterCU_Right", 170);
	SetMyRegLong("BarMeter", "BarMeterCU_Right", BarMeterCU_Right);

	BarMeterWidth = (int)(short)GetMyRegLong("BarMeter", "BarMeterCU_Width", 5);
	if (BarMeterWidth <= 0) BarMeterWidth = 5;
	BarMeterCU_Left = BarMeterCU_Right + BarMeterWidth;
	SetMyRegLong("BarMeter", "BarMeterCU_Width", BarMeterWidth);


	BarMeterCU_Bottom = (int)(short)GetMyRegLong("BarMeter", "BarMeterCU_Bottom", 0);
	if (BarMeterCU_Bottom < 0) BarMeterCU_Bottom = 0;
	SetMyRegLong("BarMeter", "BarMeterCU_Bottom", BarMeterCU_Bottom);

	BarMeterHeight = (int)(short)GetMyRegLong("BarMeter", "BarMeterCU_Height", -1);
	if (BarMeterHeight <= 0) BarMeterHeight = -1;
	if (BarMeterHeight == -1)
		BarMeterCU_Top = -1;
	else
		BarMeterCU_Top = BarMeterCU_Bottom + BarMeterHeight;
	SetMyRegLong("BarMeter", "BarMeterCU_Height", BarMeterHeight);





	b_UseBarMeterCore = GetMyRegLong("BarMeter", "UseBarMeterCore", 0);
	SetMyRegLong("BarMeter", "UseBarMeterCore", b_UseBarMeterCore);

	NumberBarMeterCore = (int)(short)GetMyRegLong("BarMeter", "NumberBarMeterCore", 8);
	if (NumberBarMeterCore < 0)
	{
		NumberBarMeterCore = 0;
		b_UseBarMeterCore = FALSE;
	}
	SetMyRegLong("BarMeter", "NumberBarMeterCore", NumberBarMeterCore);


	ColorBarMeterCore_High = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCore_High", RGB(255, 0, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCore_High", ColorBarMeterCore_High);

	ColorBarMeterCore_Mid = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCore_Mid", RGB(255, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCore_Mid", ColorBarMeterCore_Mid);

	ColorBarMeterCore_Low = (COLORREF)GetMyRegLong("BarMeter", "ColorBarMeterCore_Low", RGB(0, 255, 0));
	SetMyRegLong("BarMeter", "ColorBarMeterCore_Low", ColorBarMeterCore_Low);



	BarMeterWidth = (int)(short)GetMyRegLong("BarMeter", "BarMeterCore_Width", 5);
	BarMeterSpacing = (int)(short)GetMyRegLong("BarMeter", "BarMeterCore_Spacing", 2);
	BarMeterCore_Left = (int)(short)GetMyRegLong("BarMeter", "BarMeterCore_Left", 0);

	if (BarMeterWidth <= 0) BarMeterWidth = BarMeterCU_Left - BarMeterCU_Right;
	if (BarMeterSpacing < 0) BarMeterSpacing = 0;

	SetMyRegLong("BarMeter", "BarMeterCore_Width", BarMeterWidth);
	SetMyRegLong("BarMeter", "BarMeterCore_Spacing", BarMeterSpacing);
	SetMyRegLong("BarMeter", "BarMeterCore_Left", BarMeterCore_Left);
	
	if (BarMeterCore_Left == 0)
	{
		BarMeterCore_Left = BarMeterCU_Right - BarMeterSpacing;
	}
	BarMeterCore_Right = BarMeterCore_Left - BarMeterWidth;
	BarMeterCore_Pitch = BarMeterWidth + BarMeterSpacing;

	BarMeterCore_Bottom = BarMeterCU_Bottom;
	BarMeterCore_Top = BarMeterCU_Top;







	b_UseBarMeterNet = GetMyRegLong("BarMeter", "UseBarMeterNet", 0);
	SetMyRegLong("BarMeter", "UseBarMeterNet", b_UseBarMeterNet);

	b_BarMeterNet_LogGraph = GetMyRegLong("BarMeter", "BarMeterNet_LogGraph", 0);
	SetMyRegLong("BarMeter", "BarMeterNet_LogGraph", b_BarMeterNet_LogGraph);


	ColorBarMeterNetSend = ColSend;
	ColorBarMeterNetRecv = ColRecv;


	BarMeterNetRecv_Right = (int)(short)GetMyRegLong("BarMeter", "BarMeterNetRecv_Right", 300);
	SetMyRegLong("BarMeter", "BarMeterNetRecv_Right", BarMeterNetRecv_Right);


	BarMeterNetRecv_Bottom = (int)(short)GetMyRegLong("BarMeter", "BarMeterNetRecv_Bottom", 0);
	if (BarMeterNetRecv_Bottom < 0) BarMeterNetRecv_Bottom = 0;
	SetMyRegLong("BarMeter", "BarMeterNetRecv_Bottom", BarMeterNetRecv_Bottom);

	BarMeterNetSend_Right = (int)(short)GetMyRegLong("BarMeter", "BarMeterNetSend_Right", 310);
	SetMyRegLong("BarMeter", "BarMeterNetSend_Right", BarMeterNetSend_Right);


	BarMeterNetSend_Bottom = (int)(short)GetMyRegLong("BarMeter", "BarMeterNetSend_Bottom", 0);
	if (BarMeterNetSend_Bottom < 0) BarMeterNetSend_Bottom = 0;
	SetMyRegLong("BarMeter", "BarMeterNetSend_Bottom", BarMeterNetSend_Bottom);

	BarMeterWidth = (int)(short)GetMyRegLong("BarMeter", "BarMeterNet_Width", 5);
	if (BarMeterWidth <= 0) BarMeterWidth = 5;
	BarMeterNetRecv_Left = BarMeterNetRecv_Right + BarMeterWidth;
	BarMeterNetSend_Left = BarMeterNetSend_Right + BarMeterWidth;
	SetMyRegLong("BarMeter", "BarMeterNet_Width", BarMeterWidth);


	BarMeterHeight = (int)(short)GetMyRegLong("BarMeter", "BarMeterNet_Height", -1);
	if (BarMeterHeight <= 0) BarMeterHeight = -1;
	if (BarMeterHeight == -1)
	{
		BarMeterNetRecv_Top = -1;
		BarMeterNetSend_Top = -1;
	}
	else
	{
		BarMeterNetRecv_Top = BarMeterNetRecv_Bottom + BarMeterHeight;
		BarMeterNetSend_Top = BarMeterNetSend_Bottom + BarMeterHeight;
	}
	SetMyRegLong("BarMeter", "BarMeterNet_Height", BarMeterHeight);



	SetMyRegLong("Status_DoNotEdit", "BatteryLifeAvailable", 1);

	GetMyRegStr("ETC", "DisplayString_Single", strDispSingle, 32, "-1-");
	SetMyRegStr("ETC", "DisplayString_Single", strDispSingle);

	GetMyRegStr("ETC", "DisplayString_Clone", strDispClone, 32, "1=2");
	SetMyRegStr("ETC", "DisplayString_Clone", strDispClone);

	GetMyRegStr("ETC", "DisplayString_Extend", strDispExtend, 32, "1+2");
	SetMyRegStr("ETC", "DisplayString_Extend", strDispExtend);

	NetMIX_Length = GetMyRegLong("ETC", "NetMIX_Length", 10);
	SetMyRegLong("ETC", "NetMIX_Length", NetMIX_Length);

	SSID_AP_Length = GetMyRegLong("ETC", "SSID_AP_Length", 10);
	SetMyRegLong("ETC", "SSID_AP_Length", SSID_AP_Length);

	strcpy(strDispStatus, strDispSingle);





	strAdditionalMountPath[10][64];

	for (int i = 0; i < 10; i++) {
		sprintf(strTemp, "AdditionalMountPath%1d", i);
		GetMyRegStr("ETC", strTemp, strAdditionalMountPath[i], 64, "");
		SetMyRegStr("ETC", strTemp, strAdditionalMountPath[i]);
	}



	AdjustThreshold = GetMyRegLong(NULL, "AdjustThreshold", 200);
	if (AdjustThreshold < 100) AdjustThreshold = 100;
	if (AdjustThreshold > 500) AdjustThreshold = 500;
	SetMyRegLong(NULL, "AdjustThreshold", AdjustThreshold);


	TimerCountForSec = GetMyRegLong("Status_DoNotEdit", "TimerCountForSec", 1000);
	if (AdjustThreshold > 400) TimerCountForSec = 1000;
	else if (TimerCountForSec > 1030) TimerCountForSec = 1030;
	else if (TimerCountForSec < 970) TimerCountForSec = 970;
	SetMyRegLong("Status_DoNotEdit", "TimerCountForSec", TimerCountForSec);



	CalcMainClockSize();


	if(bGraphTimerStart) KillTimer(hwndClockMain, IDTIMERDLL_GRAPH); bGraphTimerStart = FALSE;
	if(bGraph)
		bGraphTimerStart = SetTimer(hwndClockMain, IDTIMERDLL_GRAPH, graphInterval*1000, NULL) != 0;

	GetMyRegStr("Format", "Format", format, 1024, "mm/dd ddd\\n hh:nn:ss ");

	// 時計の書式は読み込み時に<%〜%>を追加する
	{
		char fmt_tmp[1024];
		strcpy(fmt_tmp,"<%");
		strcat(fmt_tmp,format);
		strcat(fmt_tmp,"%>");
		strcpy(format,fmt_tmp);
	}

	//if(bWatchTaskWnd) KillTimer(hwndClockMain, IDTIMERDLL_WATCHTASKWND);
	//bWatchTaskWnd = GetMyRegLong(NULL, "WatchTaskbarWindow", FALSE);
	//if(bWatchTaskWnd) SetTimer(hwndClockMain, IDTIMERDLL_WATCHTASKWND, 200, NULL);




	dwInfoFormat = FindFormat(format);
	bDispSecond = (dwInfoFormat&FORMAT_SECOND)? TRUE:FALSE;
	nDispBeat = dwInfoFormat & (FORMAT_BEAT1 | FORMAT_BEAT2);

	bHour12 = GetMyRegLong("Format", "Hour12", 0);
	bHourZero = GetMyRegLong("Format", "HourZero", 0);

	GetLocalTime(&lt);
	LastTime.wDay = lt.wDay;
	b_DayChange = TRUE;

	InitFormat(&lt);      // format.c

	//iClockWidth = -1;

	InitSysInfo();


	//Start Timers
	intervalTimerAdjust = 10;		// Enable first adjustment in 3 sec, added by TTTT	
	b_InitialTimerAdjust = TRUE;	// Do not change TimerCountForSec in the  first adjustment, added by TTTT
	SetTimer(hwndClockMain, IDTIMERDLL_DLLMAIN, TimerCountForSec, NULL);
	bTimer = TRUE;
	//Following Timers will be adjusted in the first call of the timeout functions
	//if (bTimerSysInfo) KillTimer(hwndClockMain, IDTIMERDLL_SYSINFO);
	//if (bTimerCheckNetStat) KillTimer(hwndClockMain, IDTIMERDLL_CHECKNETSTAT);

	SetTimer(hwndClockMain, IDTIMERDLL_SYSINFO, TimerCountForSec + OFFSETMS_TIMER_SYSINFO, NULL);
	bTimerSysInfo = TRUE;
	bTimerAdjust_SysInfo = TRUE;
	SetTimer(hwndClockMain, IDTIMERDLL_CHECKNETSTAT, TimerCountForSec + OFFSETMS_TIMER_NETSTAT, NULL);
	bTimerCheckNetStat = TRUE;
	bTimerAdjust_NetStat = TRUE;



}

void InitSysInfo()
{
	DWORD dwInfoFormat, dwInfoTip;

	//if(bTimerSysInfo) KillTimer(hwndClockMain, IDTIMERDLL_SYSINFO);	// deactivated by TTTT
	bDispSysInfo = bTimerSysInfo = FALSE;
	bGetSysRes = bGetBattery = bGetMem = FALSE;
	memset(&msMemory, 0, sizeof(msMemory));

	dwInfoFormat = FindFormat(format);
	dwInfoTip = TooltipFindFormat();

	bGetSysRes = (((dwInfoFormat | dwInfoTip) & FORMAT_SYSINFO))? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_SYSINFO) bDispSysInfo = TRUE;


	{
		bGetBattery = ((dwInfoFormat | dwInfoTip) & FORMAT_BATTERY)? TRUE:FALSE;
		if(dwInfoFormat & FORMAT_BATTERY) bDispSysInfo = TRUE;
		if (b_UseBarMeterBL) bGetBattery = TRUE;	//Added by TTTT 2011028
	}
	bGetBattery = TRUE; //Modified to check battery availability as default. Modified by TTTT

	bGetMem = ((dwInfoFormat | dwInfoTip) & FORMAT_MEMORY)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_MEMORY) bDispSysInfo = TRUE;

	bGetMb = ((dwInfoFormat | dwInfoTip) & FORMAT_MOTHERBRD)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_MOTHERBRD) bDispSysInfo = TRUE;

	bGetPm = ((dwInfoFormat | dwInfoTip) & FORMAT_PERMON)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_PERMON) bDispSysInfo = TRUE;

	bGetNet = (((dwInfoFormat | dwInfoTip) & FORMAT_NET)||(bGraph&&graphMode==1))? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_NET) bDispSysInfo = TRUE;

	bGetHdd = ((dwInfoFormat | dwInfoTip) & FORMAT_HDD)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_HDD) bDispSysInfo = TRUE;

	bGetCpu = ((dwInfoFormat | dwInfoTip) & FORMAT_CPU)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_CPU) bDispSysInfo = TRUE;
	if (b_UseBarMeterCU) bGetCpu = TRUE;	//Added by TTTT 2011028

	bGetVol = ((dwInfoFormat | dwInfoTip) & FORMAT_VOL)? TRUE:FALSE;
	if(dwInfoFormat & FORMAT_VOL) bDispSysInfo = TRUE;

	bGetDispInfo = ((dwInfoFormat | dwInfoTip) & FORMAT_DISPLAY) ? TRUE : FALSE;


	if(bGetSysRes || bGetBattery || bGetMem || bGetMb || bGetPm || bGetNet || bGetHdd || bGetCpu || bGetVol)
	{
		UpdateSysRes(bGetSysRes, bGetBattery, bGetMem, bGetMb, bGetPm, bGetNet, bGetHdd, bGetCpu, bGetVol);
	}

}



/*------------------------------------------------
　描画用メモリDCの作成
 hdcClockとhdcClock_workを作る(作り直す)
--------------------------------------------------*/
void CreateClockDC(void)
{
	RECT tempRect;
	//COLORREF col;
	HDC hdc;
	char s[1024];
	int tempWidth, tempHeight;


	if (b_DebugLog)writeDebugLog_Win10("[tclock.c] CreateClockDC called", 999);


	//すでにhdcClockがある場合には、消す。
	if(hdcClock)
	{
//		if (hbmpClockOld) SelectObject(hdcClock, hbmpClockOld);
		DeleteDC(hdcClock);
		hdcClock = NULL;
	}

	if (hdcClock_work)
	{
		//		if (hbmpClockOld) SelectObject(hdcClock, hbmpClockOld);
		DeleteDC(hdcClock_work);
		hdcClock_work = NULL;
	}

	//すでにhbm_DIBSectionが存在する場合には、クリアして消す。
	if (hbm_DIBSection) {
		DeleteObject(hbm_DIBSection);
		hbm_DIBSection = NULL;
	}

	if (hbm_DIBSection_work) {
		DeleteObject(hbm_DIBSection_work);
		hbm_DIBSection_work = NULL;
	}

	//メイン時計サイズを取得
	//CreateClockDCはSetMainClockOnTasktrayから、時計サイズ更新直後にしか呼ばれないので、時計サイズは保存されている値が有効
	//ただし、SetMainClockOnTasktrayでhwndClockMainのサイズにFrameのサイズとContentのサイズのどちらを設定するのかの設定を
	//rectMainClockで維持することにする。

	//GetClientRect(hwndClockMain, &tempRect);
	//if (b_DebugLog)
	//{
	//	writeDebugLog_Win10("[tclock.c][CreateClockDC] tempRect.left   = ", tempRect.left);
	//	writeDebugLog_Win10("[tclock.c][CreateClockDC] tempRect.top    = ", tempRect.top);
	//	writeDebugLog_Win10("[tclock.c][CreateClockDC] tempRect.right  = ", tempRect.right);
	//	writeDebugLog_Win10("[tclock.c][CreateClockDC] tempRect.bottom = ", tempRect.bottom);
	//}

	tempWidth = rectMainClock.right - rectMainClock.left;
	tempHeight = rectMainClock.bottom - rectMainClock.top;


	//新しいhdcを取得する。
//	hdc = GetDC(NULL);
	//こっちで行けるのでは？ 20211112
	hdc = GetDC(hwndClockMain);


	//hdcClock = GetDC(hwndClockMain);としてしまうと、hdcClockが仮想ワークエリアではなく時計ウィンドウに直結してしまう。
	//なので、CreateCompatibleDCを使う
	hdcClock = CreateCompatibleDC(hdc);
	if(!hdcClock)	//失敗した場合は諦める…起こらないはず。
	{
		ReleaseDC(NULL, hdc);
		return;
	}


	hdcClock_work = CreateCompatibleDC(hdcClock);
	if (!hdcClock_work)
	{
		ReleaseDC(NULL, hdc);
		return;
	}

	//3.4.5.2 (2021/10/14) by TTTT
	////もともとビットマップとしてhbmpClockを使っていたが、hbm_DIBSectionを使う方法に移行した(必要なかったかもしれないが、参考にしたreduxのコードに併せた)。hbmpClockは使わなくなった。
	//hbmpClock = CreateCompatibleBitmap(hdc, tempRect.right, tempRect.bottom);

	//if(!hbmpClock)
	//{
	//	DeleteDC(hdcClock); hdcClock = NULL;
	//	ReleaseDC(NULL, hdc);
	//	return;
	//}

	//hbmpClockOld = SelectObject(hdcClock, hbmpClock);
	
	//以下、tempRect.left, tempRect.topが0なのでうまく行くが、本来は左右差、上下差で幅と高さを決定すべき

	static BITMAPINFO bmi = { { sizeof(BITMAPINFO),0,0,1,32,BI_RGB }, };
	//bmi.bmiHeader.biWidth = tempRect.right;
	//bmi.bmiHeader.biHeight = tempRect.bottom;
	bmi.bmiHeader.biWidth = tempWidth;
	bmi.bmiHeader.biHeight = tempHeight;

	hbm_DIBSection = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, (void**)&m_color_start, NULL, 0);
//	m_color_end = m_color_start + (tempRect.right*tempRect.bottom);
	m_color_end = m_color_start + (tempWidth * tempHeight);
	SelectObject(hdcClock, hbm_DIBSection);
//	hbmpClockOld = SelectObject(hdcClock, hbm_DIBSection);

	hbm_DIBSection_work = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, (void**)&m_color_work_start, NULL, 0);
//	m_color_work_end = m_color_work_start + (tempRect.right*tempRect.bottom);
	m_color_work_end = m_color_work_start + (tempWidth * tempHeight);
	SelectObject(hdcClock_work, hbm_DIBSection_work);


	//3.4.5.2では、TextOutの直接の対象は、背景透過時はhdcClock_workに仮描画(α値として取得するため)、背景非透過時はhdcClockに直接描画することにする。



	SetTClockFont();

//	SelectObject(hdcClock, hFon);

	if (nTextPos == 1)
		SetTextAlign(hdcClock, TA_LEFT | TA_TOP);
	else if (nTextPos == 2)
		SetTextAlign(hdcClock, TA_RIGHT | TA_TOP);
	else
		SetTextAlign(hdcClock, TA_CENTER | TA_TOP);

	SetBkMode(hdcClock, TRANSPARENT);




//	SelectObject(hdcClock_work, hFon);

	if (nTextPos == 1)
		SetTextAlign(hdcClock_work, TA_LEFT | TA_TOP);
	else if (nTextPos == 2)
		SetTextAlign(hdcClock_work, TA_RIGHT | TA_TOP);
	else
		SetTextAlign(hdcClock_work, TA_CENTER | TA_TOP);

	SetBkMode(hdcClock_work, TRANSPARENT);

//	FillClock(hwndClockMain, hdc, &tempRect, 0);

	ReleaseDC(NULL, hdc);
}

/*------------------------------------------------
   get date/time and beat to display
--------------------------------------------------*/
void GetDisplayTime(SYSTEMTIME* pt, int* beat100)
{
	FILETIME ft, lft;
	SYSTEMTIME lt;

	GetSystemTimeAsFileTime(&ft);

	if(beat100)
	{
		DWORDLONG dl;
		SYSTEMTIME st;
		int sec;

		dl = *(DWORDLONG*)&ft + 36000000000;
		FileTimeToSystemTime((FILETIME*)&dl, &st);

		sec = st.wHour * 3600 + st.wMinute * 60 + st.wSecond;
		*beat100 = (sec * 1000) / 864;
	}

	FileTimeToLocalFileTime(&ft, &lft);
	FileTimeToSystemTime(&lft, &lt);
	memcpy(pt, &lt, sizeof(lt));
}

/*------------------------------------------------
　WM_TIMER の処理 New Version for TClock-Win10
 --------------------------------------------------*/
void OnTimer_Win10(void)
{
	SYSTEMTIME t;
	int beat100 = 0;
	//HDC hdc;
	BOOL bRedraw;


	GetDisplayTime(&t, nDispBeat ? (&beat100) : NULL);



	if (b_DebugLog)
	{
		if (t.wMilliseconds < 500) writeDebugLog_Win10("[tclock.c] OnTimer_Win10 called. Delay(ms) = ", t.wMilliseconds);
		else writeDebugLog_Win10("[tclock.c] OnTimer_Win10 called. Delay(ms) = -", (1000 - t.wMilliseconds));
	}

	intervalTimerAdjust++;


	if (t.wMilliseconds > AdjustThreshold && intervalTimerAdjust > 9) // suppress multiple adjust in short time
	{
		int ms_adjust;

		if (t.wMilliseconds < 500) ms_adjust = 1025 - t.wMilliseconds;
		else ms_adjust = 2025 - t.wMilliseconds;
		
		if (!b_InitialTimerAdjust)	//Do not change TimerCountForSec in the initial adjust.
		{
			if (t.wMilliseconds < 500)
			{
				TimerCountForSec--;
			}
			else
			{
				TimerCountForSec++;
			}
		}

		if (AdjustThreshold > 400) TimerCountForSec = 1000;
		else if (TimerCountForSec > 1030) TimerCountForSec = 1030;
		else if (TimerCountForSec < 970) TimerCountForSec = 970;


		KillTimer(hwndClockMain, IDTIMERDLL_DLLMAIN);
		SetTimer(hwndClockMain, IDTIMERDLL_DLLMAIN, ms_adjust, NULL);
		bTimerDLLMainAdjust = TRUE;
		b_FlagTimerAdjust = TRUE;

		SetMyRegLong("Status_DoNotEdit", "TimerCountForSec", TimerCountForSec);

		SetTimer(hwndClockMain, IDTIMERDLL_SYSINFO, ms_adjust + OFFSETMS_TIMER_SYSINFO, NULL);
		bTimerAdjust_SysInfo = TRUE;
		SetTimer(hwndClockMain, IDTIMERDLL_CHECKNETSTAT, ms_adjust + OFFSETMS_TIMER_NETSTAT, NULL);
		bTimerAdjust_NetStat = TRUE;

		if (b_DebugLog)
		{
			writeDebugLog_Win10("[OnTimer_Win10] IDTIMERDLL_DLLMAIN adjusted with TimerCountForSec =", TimerCountForSec);
			if (b_InitialTimerAdjust) writeDebugLog_Win10("[OnTimer_Win10] Startup Timer adjustment was performed.", 999);
				else writeDebugLog_Win10("[OnTimer_Win10] Seconds after the last Timer adjustment =", intervalTimerAdjust);
		}

		intervalTimerAdjust = 0;

	}
	else if (bTimerDLLMainAdjust)
	{
		KillTimer(hwndClockMain, IDTIMERDLL_DLLMAIN);
		bTimerDLLMainAdjust = FALSE;
		SetTimer(hwndClockMain, IDTIMERDLL_DLLMAIN, TimerCountForSec, NULL);
	}

	b_InitialTimerAdjust = FALSE;



	bRedraw = FALSE;

	if (bDispSecond) bRedraw = TRUE;
	else if (nDispBeat == FORMAT_BEAT1 && beatLast != (beat100 / 100)) bRedraw = TRUE;
	else if (nDispBeat == FORMAT_BEAT2 && beatLast != beat100) bRedraw = TRUE;
	else if (bDispSysInfo) bRedraw = TRUE;
	else if (LastTime.wHour != (int)t.wHour
		|| LastTime.wMinute != (int)t.wMinute) bRedraw = TRUE;
	else if (bGraphRedraw)
	{
		bGraphRedraw = FALSE;
		bRedraw = TRUE;
	}

	if (LastTime.wDay != t.wDay || LastTime.wMonth != t.wMonth ||
		LastTime.wYear != t.wYear)
	{
		InitFormat(&t); // format.c
		GetTimeZoneBias_Win10();
		b_DayChange = TRUE;
	}

	if (b_DayChange) {
		if (IsHoliday_Win10(&t) && (ColorHolidayText < 0x1000000)) {
			colfore = ColorHolidayText;
			textcol_DoWzone = ColorHolidayText;
		}else if ((t.wDayOfWeek == 0) && (ColorSundayText < 0x1000000)) {
			colfore = ColorSundayText;
			textcol_DoWzone = ColorSundayText;
		}else if ((t.wDayOfWeek == 6) && (ColorSaturdayText < 0x1000000)) {
			colfore = ColorSaturdayText;
			textcol_DoWzone = ColorSaturdayText;
		}else {
			colfore = ColorWeekdayText;
			textcol_DoWzone = ColorWeekdayText;
		}
		b_DayChange = FALSE;
	}



	memcpy(&LastTime, &t, sizeof(t));

	if (nDispBeat == FORMAT_BEAT1) beatLast = beat100 / 100;
	else if (nDispBeat == FORMAT_BEAT2) beatLast = beat100;


	if (bRedraw)
	{
		RedrawTClock();
	}


	SendStatusDLL2Main();

	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] OnTimer_Win10 finished.", 999);

}



/*------------------------------------------------
　DLLの動作状態をMainに送信 by TTTT
 --------------------------------------------------*/
void SendStatusDLL2Main(void)
{
	WPARAM tempwParam = 0;
	if (b_DataPlanUsageRetrieving)
		tempwParam |= 0x0000001;

	if (IsWindow(hwndTClockExeMain))
		PostMessage(hwndTClockExeMain, CLOCKM_DLLALIVE, tempwParam, 0);
}



void OnTimerUpperTaskbar(void)
{
	RECT rectTaskbar, rectWnd, rectClient;
	HWND hActiveWnd;
  


	if (!hwndTaskBarMain) return;
	if (!GetWindowRect(hwndTaskBarMain, &rectTaskbar)) return;

	hActiveWnd = GetForegroundWindow();
	if (!GetWindowRect(hActiveWnd, &rectWnd)) return;
	if (rectWnd.top == rectWnd.bottom) return;
	if (rectWnd.left == rectWnd.right) return;
	if (IsZoomed(hActiveWnd)
	 || !IsWindowVisible(hActiveWnd)
	 || (rectWnd.bottom-rectWnd.top) >= GetSystemMetrics(SM_CYFULLSCREEN)
	 || (rectWnd.right-rectWnd.left) >= GetSystemMetrics(SM_CXFULLSCREEN))
		return;
	//「デスクトップの表示」で最小化されたウィンドウを復元したときに
	//ウィンドウ位置がおかしくなる問題回避
	if (!GetClientRect(hActiveWnd, &rectClient)) return;
	if (rectClient.right == 0 && rectClient.bottom == 0) return;

	if (rectTaskbar.bottom <= (GetSystemMetrics(SM_CYSCREEN)/2))
	{
		//上タスクバー
		if (rectWnd.top < rectTaskbar.bottom)
		{
			MoveWindow(hActiveWnd, rectWnd.left, rectTaskbar.bottom,
				rectWnd.right-rectWnd.left, rectWnd.bottom-rectWnd.top, TRUE);
		}
	}
	else
	if (rectTaskbar.right <= (GetSystemMetrics(SM_CXSCREEN)/2))
	{
		//左タスクバー
		if (rectWnd.left < rectTaskbar.right)
		{
			MoveWindow(hActiveWnd, rectTaskbar.right, rectWnd.top,
				rectWnd.right-rectWnd.left, rectWnd.bottom-rectWnd.top, TRUE);
		}
	}
	else
	if (rectTaskbar.left >= (GetSystemMetrics(SM_CXSCREEN)/2))
	{
		//右タスクバー
		if (rectWnd.right > rectTaskbar.left)
		{
			MoveWindow(hActiveWnd, rectTaskbar.left-(rectWnd.right-rectWnd.left) , rectWnd.top,
				rectWnd.right-rectWnd.left, rectWnd.bottom-rectWnd.top, TRUE);
		}
	}
	else
	{
		//下タスクバー
		if (rectWnd.bottom > rectTaskbar.top)
		{
			MoveWindow(hActiveWnd, rectWnd.left, rectTaskbar.top-(rectWnd.bottom-rectWnd.top),
				rectWnd.right-rectWnd.left, rectWnd.bottom-rectWnd.top, TRUE);
		}
	}
}

/*------------------------------------------------
　時計の描画 (2.5.0.2以降では使われてない。
--------------------------------------------------*/
void DrawClock(HWND hwnd, HDC hdc)
{
	SYSTEMTIME t;
	int beat100 = 0;

	GetDisplayTime(&t, nDispBeat?(&beat100):NULL);
	DrawClockSub(hdc, &t, beat100);
	DrawClockFocusRect(hdc);
}



void DrawClock_New(HDC hdc)
{
	SYSTEMTIME t;
	int beat100 = 0;

	if (hdcClock) {
		GetDisplayTime(&t, nDispBeat ? (&beat100) : NULL);
		DrawClockSub(hdc, &t, beat100);
		DrawClockFocusRect(hdc);
	}
}


static POINT ptMinHand[15] = {
	{  9,  1 },	//  0
	{ 10,  1 },	//  1
	{ 11,  2 },	//  2
	{ 12,  2 }, //  3
	{ 12,  3 }, //  4
	{ 13,  3 }, //  5
	{ 13,  3 }, //  6
	{ 14,  4 }, //  7
	{ 14,  4 }, //  8
	{ 15,  5 }, //  9
	{ 15,  5 }, // 10
	{ 16,  6 }, // 11
	{ 16,  6 }, // 12
	{ 17,  7 }, // 13
	{ 17,  8 }  // 14
};

static POINT ptHourHand[15] = {
	{  9,  1 },	//  0
	{ 10,  1 },	//  1
	{ 11,  2 },	//  2
	{ 12,  2 }, //  3
	{ 12,  3 }, //  4
	{ 13,  3 }, //  5
	{ 13,  3 }, //  6
	{ 14,  4 }, //  7
	{ 14,  4 }, //  8
	{ 15,  5 }, //  9
	{ 15,  5 }, // 10
	{ 16,  6 }, // 11
	{ 16,  6 }, // 12
	{ 17,  7 }, // 13
	{ 17,  8 }  // 14
};

static void GetHnadLinePos(WORD index, WORD sector, POINT tbl[], POINT pos[], int dx, int dy)
{
	int cx, cy;
	int sx, sy;
	int x, y;

	x = tbl[index].x;
	y = tbl[index].y;
	cx = (sizeAClock.cx / 2);
	cy = (sizeAClock.cy / 2);
	sx = x;
	sy = y;
	switch (sector) {
	case 0:
		sx = x;
		sy = y;
		//cy += 1;
		break;
	case 1:
		sx = (sizeAClock.cx) - y;
		sy = x;
		//cx -= 1;
		break;
	case 2:
		sx = (sizeAClock.cx) - x;
		sy = (sizeAClock.cy)- y;
		//cy -= 1;
		break;
	case 3:
		sx = y;
		sy = (sizeAClock.cy) - x;
		//cx += 1;
		break;
	}
	pos[0].x = cx + dx;
	pos[0].y = cy + dy;
	pos[1].x = sx + dx;
	pos[1].y = sy + dy;
}

//ビットマップヘッダーのチェック
static BOOL CheckBitmapHeader(LPBYTE top, DWORD dwFileSize)
{
	LPBITMAPFILEHEADER lpbmfh;
	LPBITMAPINFOHEADER lpbmih;
	LPBYTE			  lpOffBits;
	RGBQUAD			 *lprgb;

	if (dwFileSize <= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)) {
		// サイズ異常
		return FALSE;
	}

	lpbmfh = (BITMAPFILEHEADER *)top;
	if (lpbmfh->bfType != 0x4D42) { // BM
		//ヘッダー異常
		return FALSE;
	}
	if (lpbmfh->bfSize <= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)) {
		// サイズ異常
		return FALSE;
	}
	lpOffBits = (LPBYTE)(top + lpbmfh->bfOffBits);
	lpbmih = (BITMAPINFOHEADER *)(top + sizeof(BITMAPFILEHEADER));
	lprgb = (RGBQUAD *)(lpbmih + sizeof(BITMAPINFOHEADER));

	if (lpbmih->biSize != sizeof(BITMAPINFOHEADER)) {
		// ビットマップインフォヘッダーサイズ異常
		return FALSE;
	}

	if (lpbmih->biHeight == 0) {
		//ビットマップの高さの異常
		return FALSE;
	}

	if (lpbmih->biWidth == 0) {
		//ビットマップの幅の異常
		return FALSE;
	}
	switch (lpbmih->biBitCount) {
		case 1:
		case 4:
		case 8:
		case 16:
		case 24:
		case 32:
			break;
		default:
			//ピクセルサイズの異常
			return FALSE;
	}
	return TRUE;
}

static HBITMAP ReadBitmapData(HDC hDC, LPBYTE top, DWORD dwFileSize, SIZE *psize)
{
	LPBITMAPFILEHEADER lpbmfh;
	LPBITMAPINFO lpbmi;
	LPBITMAPINFOHEADER lpbmih;
	LPBYTE ptr;
	HBITMAP hBitmap;

	if (top == NULL) {
		return NULL;
	}
	if (!CheckBitmapHeader(top, dwFileSize)) {
		return NULL;
	}

	lpbmfh = (LPBITMAPFILEHEADER)top;
	lpbmih = (LPBITMAPINFOHEADER)(lpbmfh + 1);
	lpbmi = (LPBITMAPINFO)lpbmih;

	psize->cx = lpbmih->biWidth;
	psize->cy = lpbmih->biHeight;

	ptr = top + lpbmfh->bfOffBits;

	hBitmap = CreateDIBitmap(
		hDC,
		lpbmih,
		CBM_INIT,
		ptr,
		lpbmi,
		DIB_RGB_COLORS
	);
	if (hBitmap == NULL) {
		return NULL;
	}
	return hBitmap;
}

static HBITMAP ReadBitmapFile(HDC hDC, LPTSTR lpszFileName, SIZE *psize)
{
	HANDLE hFile;
	HANDLE hMapFile;
	LPBYTE ptr;
	DWORD dwFileSize;
	HBITMAP hBitmap;

	if (*lpszFileName == '\0') {
		return NULL;
	}
	hFile = CreateFile(
		lpszFileName,			// lpszName
		GENERIC_READ,			// fdwAccess
		FILE_SHARE_READ,		// fdwShareMode
		NULL,					// lpsa
		OPEN_EXISTING,			// fdwCreate
		FILE_ATTRIBUTE_NORMAL,	// fdwAttrsAndFlags
		NULL					// hTemplateFile
	);
	if (hFile == INVALID_HANDLE_VALUE) {
		return NULL;
	}

	dwFileSize = GetFileSize(hFile, NULL);
	if (dwFileSize == 0) {
		CloseHandle(hFile);
		return NULL;
	}

	hMapFile = CreateFileMapping(
		(HANDLE)hFile,
		NULL,
		PAGE_READONLY,
		0, 0,
		NULL
	);
	if (hMapFile == NULL) {
		CloseHandle(hFile);
		return NULL;
	}

	ptr = (LPBYTE)MapViewOfFile(
		hMapFile,
		FILE_MAP_READ,
		0, 0, 0
	);
	if (ptr == NULL) {
		CloseHandle(hMapFile);
		CloseHandle(hFile);
	}

	hBitmap = ReadBitmapData(hDC, ptr, dwFileSize, psize);

	UnmapViewOfFile(ptr);

	CloseHandle(hMapFile);

	CloseHandle(hFile);

	return hBitmap;
}

static HBITMAP Create24BitBitmap(HDC hDC, SIZE *psize, LPBYTE *ppImgBuf)
{
	HBITMAP hBitmap;
	BITMAPINFO bmi = {
		{	// bmiHeader
			sizeof(BITMAPINFOHEADER),	// DWORD	biSize;
			0,							// LONG		biWidth;
			0,							// LONG		biHeight;
			1,							// WORD		biPlanes;
			24,							// WORD		biBitCount
			BI_RGB,						// DWORD	biCompression;
			0,							// DWORD	biSizeImage;
			0,							// LONG		biXPelsPerMeter;
			0,							// LONG		biYPelsPerMeter;
			0,							// DWORD	biClrUsed;
			0							// DWORD	biClrImportant;
		}, {	// bmiColors
			{
				0x00, 0x00, 0x00
			}
		}
	};

	bmi.bmiHeader.biWidth = psize->cx;
	bmi.bmiHeader.biHeight = psize->cy;
	bmi.bmiHeader.biSizeImage = WIDTHBYTES(bmi.bmiHeader.biBitCount * psize->cx) * psize->cy;

	hBitmap = CreateDIBSection(
		hDC,
		&bmi,
		DIB_RGB_COLORS,
		ppImgBuf,
		NULL,
		0
	);
//	 GdiFlush();
	return hBitmap;
}

static VOID ModifyMaskImage(SIZE *psize, LPBYTE buf)
{
	int x, y;
	int bw;
	LPBYTE ptr;
	RGBTRIPLE *prgb;
	int cy;

	if (buf == NULL) {
		return;
	}

	bw = WIDTHBYTES(24 * psize->cx);

	ptr = buf;
	cy = psize->cy / 2;
	//mask
	for (y = 0; y < cy; y++) {
		prgb = (RGBTRIPLE *)ptr;
		for (x = 0; x < psize->cx; x++) {
			if (
				(prgb->rgbtBlue  == 0xFF) &&
				(prgb->rgbtGreen == 0x00) &&
				(prgb->rgbtRed   == 0xFF)
			) {
				prgb->rgbtBlue  = 0xFF;
				prgb->rgbtGreen = 0xFF;
				prgb->rgbtRed   = 0xFF;
			} else {
				prgb->rgbtBlue  = 0x00;
				prgb->rgbtGreen = 0x00;
				prgb->rgbtRed   = 0x00;
			}
			prgb++;
		}
		ptr += bw;
	}
	//invert
	for (y = 0; y < cy; y++) {
		prgb = (RGBTRIPLE *)ptr;
		for (x = 0; x < psize->cx; x++) {
			if (
				(prgb->rgbtBlue  == 0xFF) &&
				(prgb->rgbtGreen == 0x00) &&
				(prgb->rgbtRed   == 0xFF)
			) {
				prgb->rgbtBlue  = 0x00;
				prgb->rgbtGreen = 0x00;
				prgb->rgbtRed   = 0x00;
			}
			prgb++;
		}
		ptr += bw;
	}
}

static BOOL CreateAnalogClockDC(HWND hWnd, HDC hDC, LPTSTR fname)
{
	SIZE size;
	SIZE msize;
	PSTR path;



	if (hdcAnalogClock) {
		DeleteDC(hdcAnalogClock);
		hdcAnalogClock = NULL;
	}
	if (hbmpAnalogClock) {
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
	}
	if (hdcAnalogClockMask) {
		DeleteDC(hdcAnalogClockMask);
		hdcAnalogClockMask = NULL;
	}
	if (hbmpAnalogClockMask) {
		DeleteObject(hbmpAnalogClockMask);
		hbmpAnalogClockMask = NULL;
		lpbyAnalogClockMask = NULL;
	}

	if (*fname == '\0') {
		return FALSE;
	}

	path = CreateFullPathName(hmod, fname);
	if (path == NULL) {
		hbmpAnalogClock = ReadBitmapFile(hDC, fname, &size);
	} else {
		hbmpAnalogClock = ReadBitmapFile(hDC, path, &size);
		free(path);
	}
	if (hbmpAnalogClock == NULL) {
		hdcAnalogClock = NULL;
		return TRUE;
	}
	sizeAnalogBitmapSize = size;
	msize = size;
	msize.cy *= 2;
	hbmpAnalogClockMask = Create24BitBitmap(hDC, &msize, &lpbyAnalogClockMask);
	if (hbmpAnalogClockMask == NULL) {
		lpbyAnalogClockMask = NULL;
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
		return FALSE;
	}

	hdcAnalogClock = CreateCompatibleDC(hDC);
	if (hdcAnalogClock == NULL) {
		DeleteObject(hbmpAnalogClockMask);
		hbmpAnalogClockMask = NULL;
		lpbyAnalogClockMask = NULL;
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
		return FALSE;
	}

	hdcAnalogClockMask = CreateCompatibleDC(hDC);
	if (hdcAnalogClockMask == NULL) {
		DeleteDC(hdcAnalogClock);
		hdcAnalogClock = NULL;
		DeleteObject(hbmpAnalogClockMask);
		hbmpAnalogClockMask = NULL;
		lpbyAnalogClockMask = NULL;
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
		return FALSE;
	}

	SelectObject(hdcAnalogClock, hbmpAnalogClock);
	SelectObject(hdcAnalogClockMask, hbmpAnalogClockMask);

	BitBlt(hdcAnalogClockMask, 0,       0, size.cx, size.cy, hdcAnalogClock, 0, 0, SRCCOPY);
	BitBlt(hdcAnalogClockMask, 0, size.cy, size.cx, size.cy, hdcAnalogClock, 0, 0, SRCCOPY);

	ModifyMaskImage(&msize, lpbyAnalogClockMask);

	if (hdcAnalogClock) {
		DeleteDC(hdcAnalogClock);
		hdcAnalogClock = NULL;
	}
	if (hbmpAnalogClock) {
		DeleteObject(hbmpAnalogClock);
		hbmpAnalogClock = NULL;
	}

	return TRUE;
}

static double ctbl[15] = {
	0.000000,
	0.104528,
	0.207912,
	0.309017,
	0.406737,
	0.500000,
	0.587785,
	0.669131,
	0.743145,
	0.809017,
	0.866025,
	0.913545,
	0.951057,
	0.978148,
	0.994522
};

static double stbl[15] = {
	0.000000,
	0.994522,
	0.978148,
	0.951057,
	0.913545,
	0.866025,
	0.809017,
	0.743145,
	0.669131,
	0.587785,
	0.500000,
	0.406737,
	0.309017,
	0.207912,
	0.104528
};

static VOID MakePosTable(int cx, int cy)
{
	int x, y;
	int x2, y2;
	double c, s;
	int i;
	int r;
	int sr;


	// x2 = x * cosA - y * sinA
	// y2 = x * sinA + y * cosA
	// ラジアン = (角度)＊（π/180）
	r = cx / 2;
	sr = r;

	x = sr;
	y = 0;
	for (i = 14; i > 0; i--) {
		c = ctbl[i];
		s = stbl[i];
		x2 = (int)(x * c - y * s);
		y2 = (int)(x * s + y * c);
		ptMinHand[i].x = x2 + r;
		ptMinHand[i].y = r - y2;
	}
	ptMinHand[0].x = r;
	ptMinHand[0].y = r - sr;

	r = cx / 2;
	sr = r * 7 / 10;

	x = sr;
	y = 0;
	for (i = 14; i > 0; i--) {
		c = ctbl[i];
		s = stbl[i];
		x2 = (int)(x * c - y * s);
		y2 = (int)(x * s + y * c);
		ptHourHand[i].x = x2 + r;
		ptHourHand[i].y = r - y2;
	}
	ptHourHand[0].x = r;
	ptHourHand[0].y = r - sr;
}

static VOID SetAnalogClockSize(SIZE *s)
{
	s->cy = s->cx = (int)(short)GetMyRegLong("AnalogClock", "AnalogClockSize", ACLOCK_SIZE_CX);
	if (s->cy <= 0) {
		s->cx = ACLOCK_SIZE_CX;
		s->cy = ACLOCK_SIZE_CY;
	}
	MakePosTable(s->cx, s->cy);
}

static BOOL InitAnalogClockData(HWND hWnd)
{
	//実際にはhWnd = hwndClockMain
	BOOL use;
	int confNo;
	TCHAR fname[MAX_PATH];
	HDC hDC;


	confNo = 1;

	use = GetMyRegLong("AnalogClock", "UseAnalogClock", FALSE);
	if (use == FALSE) {
		nAnalogClockUseFlag = ANALOG_CLOCK_NOTUSE;
		nAnalogClockPos = ANALOG_CLOCK_POS_MIDDLE;
		sizeAClock.cx = 0;
		sizeAClock.cy = 0;
		return FALSE;
	}

	nAnalogClockHPos = (int)(short)GetMyRegLong("AnalogClock", "AnalogClockHPos", 0);
	nAnalogClockVPos = (int)(short)GetMyRegLong("AnalogClock", "AnalogClockVPos", 0);
	nAnalogClockPos = (int)(short)GetMyRegLong("AnalogClock", "AnalogClockPos", 0);

	colAClockHourHandColor = (COLORREF)GetMyRegLong("AnalogClock", "AClockHourHandColor", (LONG)RGB(255, 0, 0));
	colAClockMinHandColor = (COLORREF)GetMyRegLong("AnalogClock", "AClockMinHandColor", (LONG)RGB(0, 0, 255));

	if (hpenHour) {
		DeleteObject(hpenHour);
	}
	if (hpenMin) {
		DeleteObject(hpenMin);
	}

	if (GetMyRegLong("AnalogClock", "AnalogClockHourHandBold", FALSE)) {
		nHourPenWidth = 2;
	} else {
		nHourPenWidth = 1;
	}
	if (GetMyRegLong("AnalogClock", "AnalogClockMinHandBold", FALSE)) {
		nMinPenWidth = 2;
	} else {
		nMinPenWidth = 1;
	}

	hpenHour = CreatePen(PS_SOLID, nHourPenWidth, colAClockHourHandColor);
	hpenMin = CreatePen(PS_SOLID, nMinPenWidth, colAClockMinHandColor);

	SetAnalogClockSize(&sizeAClock);

	GetMyRegStr("AnalogClock", "AnalogClockBmp", fname, MAX_PATH, "..\\tclock.bmp");
	lstrcpy(szAnalogClockBmp, fname);

	hDC = GetDC(hwndClockMain);
	CreateAnalogClockDC(hwndClockMain, hDC, szAnalogClockBmp);
	ReleaseDC(hwndClockMain, hDC);

	nAnalogClockUseFlag = ANALOG_CLOCK_USE;

	return TRUE;
}

static VOID DrawAnalogClockHand(HDC hDC, int dx, int dy, SYSTEMTIME* pt)
{
	HPEN hpenOld;
	WORD index;
	WORD sector;
	POINT posPoly[2];

	hpenOld = SelectObject(hDC, hpenHour);

	index = ((pt->wHour % 12) * 5) + (pt->wMinute / 12);
	sector = index / 15;
	index %= 15;
	GetHnadLinePos(index, sector, ptHourHand, posPoly, dx, dy);

	Polyline(hDC, posPoly, 2);

	SelectObject(hDC, hpenMin);

	index  = pt->wMinute % 15;
	sector = pt->wMinute / 15;
	GetHnadLinePos(index, sector, ptMinHand, posPoly, dx, dy);
	Polyline(hDC, posPoly, 2);

	SelectObject(hDC, hpenOld);
}

static VOID AnalogClockBlt(HDC hDC, int dx, int dy, SIZE *pdst, int sx, int sy, SIZE *psrc)
{
	if (
		(pdst->cx == sizeAnalogBitmapSize.cx) &&
		(pdst->cy == sizeAnalogBitmapSize.cy)
	) {
		BitBlt(
			hDC,
			dx, dy, pdst->cx, pdst->cy,
			hdcAnalogClockMask,
			sx, sy + sizeAnalogBitmapSize.cy,
			SRCAND
		);
		BitBlt(
			hDC,
			dx, dy, pdst->cx, pdst->cy,
			hdcAnalogClockMask,
			sx, sy,
			SRCINVERT
		);
	} else {
		StretchBlt(
			hDC,
			dx, dy, pdst->cx, pdst->cy,
			hdcAnalogClockMask,
			sx, sy + sizeAnalogBitmapSize.cy,
			psrc->cx, psrc->cy,
			SRCAND
		);
		StretchBlt(
			hDC,
			dx, dy,
			pdst->cx, pdst->cy,
			hdcAnalogClockMask,
			sx, sy,
			psrc->cx, psrc->cy,
			SRCINVERT
		);
	}
}

BOOL DrawAnalogClock(HDC hDC, SYSTEMTIME* pt, int xclock, int yclock, int wclock, int hclock)
{
//	RECT r;
	int sx, sy, dx, dy;
	SIZE clock_size;
	SIZE bitmapsize;



	if (hdcAnalogClockMask != NULL) {

		clock_size = sizeAClock;
		bitmapsize = sizeAnalogBitmapSize;

		if (nAnalogClockPos == ANALOG_CLOCK_POS_RIGHT) {
			sx = 0;
			dx = xclock + wclock - sizeAClock.cx + nAnalogClockHPos;
			if (dx >= xclock + wclock) {
				return FALSE;
			}
			if (dx < 0) {
				if (dx + sizeAClock.cx <= 0) {
					return FALSE;
				}
				sx = 0 - dx;
				clock_size.cx = clock_size.cx + dx;
				sx = sx * sizeAnalogBitmapSize.cx / sizeAClock.cx;
				dx = xclock;
				bitmapsize.cx = bitmapsize.cx - sx;
			}
		} else {
			if (nAnalogClockHPos < 0) {
				dx = xclock;
				if (nAnalogClockHPos + sizeAClock.cx <= 0) {
					return FALSE;
				}
				sx = 0 - nAnalogClockHPos;
				clock_size.cx = sizeAClock.cx + nAnalogClockHPos;
				sx = sx * sizeAnalogBitmapSize.cx / sizeAClock.cx;
				bitmapsize.cx = bitmapsize.cx - sx;
			} else {
				sx = 0;
				dx = xclock + nAnalogClockHPos;
			}
		}

		if (nAnalogClockVPos < 0) {
			dy = yclock;
			if (nAnalogClockVPos + sizeAClock.cy <= 0) {
				return FALSE;
			}
			sy = 0 - nAnalogClockVPos;
			clock_size.cy = sizeAClock.cy + nAnalogClockVPos;
			sy = sy * sizeAnalogBitmapSize.cy / sizeAClock.cy;
			bitmapsize.cy = bitmapsize.cy - sy;
		} else {
			sy = 0;
			dy = yclock + nAnalogClockVPos;
		}
		AnalogClockBlt(hDC, dx, dy, &clock_size, sx, sy, &bitmapsize);
	}

	if (nAnalogClockPos == ANALOG_CLOCK_POS_RIGHT) {
		dx = xclock + wclock - sizeAClock.cx + nAnalogClockHPos;
		dy = yclock + nAnalogClockVPos;
	} else {
		dx = xclock + nAnalogClockHPos;
		dy = yclock + nAnalogClockVPos;
	}
	DrawAnalogClockHand(hDC, dx, dy, pt);

	return TRUE;
}


static BOOL LocalDrawAnalogClock(HDC hDC, SYSTEMTIME* pt, int xclock, int yclock, int wclock, int hclock)
{
//	RECT r;
	static WORD lastSec = 0xFFFF;
	static WORD lastMin = 0xFFFF;
	static WORD lastHour = 0xFFFF;
	BOOL bRedraw;

	if (nAnalogClockUseFlag != ANALOG_CLOCK_USE) {
		return FALSE;
	}


	return DrawAnalogClock(hDC, pt, xclock, yclock, wclock, hclock);
}


static void DrawClockFocusRect(HDC hdc)
{
	if (bGetingFocus != FALSE) {
		RECT rc;

		GetClientRect(hwndClockMain, &rc);
		DrawFocusRect(hdc, &rc);
	}
}


void Textout_Tclock_Win10(int x, int y, char* sp, COLORREF textshadow, COLORREF textcol_temp)
{
	if (bClockShadow)
	{
		SetTextColor(hdcClock, textshadow);
		TextOut(hdcClock, x + nShadowRange, y + nShadowRange, sp, strlen(sp));
	}
	if (bClockBorder)
	{
		SetTextColor(hdcClock, textshadow);
		TextOut(hdcClock, x - 1, y + 1, sp, strlen(sp));
		TextOut(hdcClock, x + 1, y - 1, sp, strlen(sp));
		TextOut(hdcClock, x + 1, y + 1, sp, strlen(sp));
		TextOut(hdcClock, x, y - 1, sp, strlen(sp));
		TextOut(hdcClock, x + 1, y , sp, strlen(sp));
		TextOut(hdcClock, x - 1, y - 1, sp, strlen(sp));
	}
	SetTextColor(hdcClock, textcol_temp);
	TextOut(hdcClock, x, y, sp, strlen(sp));
}

//3.4.5.2 (2021/10/14) by TTTT
//hdcClock_workにいったん書き込んでフォント周りのαを取得する
//Rチャネル->textcol
//Gチャネル->textcol_DoWzone
//Bチャネル->textshadow
//のそれぞれのα値が得られる
void Textout_Tclock_Win10_2(int x, int y, char* sp, COLORREF textshadow, COLORREF textcol_temp)
{
	if (fillbackcolor) {
		Textout_Tclock_Win10(x, y, sp, textshadow, textcol_temp);
		return;
	}

	if (bClockShadow)
	{
		SetTextColor(hdcClock_work, RGB(0,0,255));
		TextOut(hdcClock_work, x + nShadowRange, y + nShadowRange, sp, strlen(sp));
	}
	if (bClockBorder)
	{
		SetTextColor(hdcClock_work, RGB(0, 0, 255));
		TextOut(hdcClock_work, x - 1, y + 1, sp, strlen(sp));
		TextOut(hdcClock_work, x + 1, y - 1, sp, strlen(sp));
		TextOut(hdcClock_work, x + 1, y + 1, sp, strlen(sp));
		TextOut(hdcClock_work, x, y - 1, sp, strlen(sp));
		TextOut(hdcClock_work, x + 1, y, sp, strlen(sp));
		TextOut(hdcClock_work, x - 1, y - 1, sp, strlen(sp));
	}
	if (textcol_temp == textcol_DoWzone) {
		SetTextColor(hdcClock_work, RGB(0, 255, 0));
	}
	else {
		SetTextColor(hdcClock_work, RGB(255, 0, 0));
	}

	TextOut(hdcClock_work, x, y, sp, strlen(sp));
}



/*------------------------------------------------
  draw the clock
--------------------------------------------------*/
void DrawClockSub(HDC hdc, SYSTEMTIME* pt, int beat100)
{
	BITMAP bmp;
	RECT rcFill,  rcClock;

	TEXTMETRIC tm;
	int hf, y, w;
	char s[1024], *p, *sp;
	//COLORREF s_col[1024];
	SIZE sz;
	int xclock, yclock, wclock, hclock, xsrc, ysrc, wsrc, hsrc;
	int xcenter;
	HRGN hRgn = NULL, hOldRgn = NULL;
	COLORREF textcol, textshadow;

	RGBQUAD* color;
	RGBQUAD* color_work;

	extern BOOL b_exist_DOWzone;
	extern int pos_DOWzone;
	extern int length_DOWzone;
	extern int dow_DOWzone;







	if (flag_VPN && (ColorVPNText < 0x1000000)) textcol = ColorVPNText;
	else if (b_exist_DOWzone) {
		textcol = ColorWeekdayText;
	}else{
		textcol = colfore;
	}



	if(textcol & 0x80000000) textcol = GetSysColor(textcol & 0x00ffffff);

	textshadow = colShadow;
	if(textshadow & 0x80000000) textshadow = GetSysColor(textshadow & 0x00ffffff);

	//3.4.5.2 (2021/10/14) by TTTT
	//3.4.4.1までは以下のように取得した背景色を背景として設定していた。TextOutの際の縁の色に影響を与えるため。
//	SetBkColor(hdcClock, colorBG_original);

	//3.4.5.2からは、完全な透過合成の処理ができるようになったので、真っ黒で大丈夫になった(背景色は使わないでも処理できるようになった。
	//さらに文字はいったんhdcClock_workに出力するので以下の行は実際は不要になった。グラフはhdcClockに直接出力するが、境界部での中間色処理がないので背景設定も不要
//	SetTextColor(hdcClock, textcol);
//	SetBkColor(hdcClock, RGB(0, 0, 0));


	SetBkColor(hdcClock_work, RGB(0,0,0));	//_workのビットマップは背景を黒にしてフォントのαを取得するためのワークエリアとする。

	for (color = m_color_start; color < m_color_end; ++color) {
		//To write memory, the order is 0xRRrrggbb, different from colorref = 0x00bbggrr
		//rgbReserved(25-32ビット)はアルファ値として利用されるが、ここではいったんFFを入れる。TextOut関数やグラフ記述処理で書き換えが起こると0になることを利用して後の処理を行う。


		//3.4.4.1までは以下のように取得した背景色を入れていた。TextOutの際の縁の色に影響を与えるため。
	//	*(unsigned*)color = 0xFF000000 | (colorBG_original & 0x0000FF00) | ((colorBG_original & 0xFF) << 16) | ((colorBG_original >> 16) & 0xFF);
		//3.4.5.2 (2021/10/14)からは、完全な透過合成の処理ができるようになったので、真っ黒で大丈夫になった(背景色は使わないでも処理できるようになった。
		*(unsigned*)color = 0xFF000000;
	}

	for (color = m_color_work_start; color < m_color_work_end; ++color) {
		//透過表示用のビットマップにも同様の処理を施す。
		//To write memory, the order is 0xRRrrggbb, different from colorref = 0x00bbggrr
		//rgbReserved(25-32ビット)はアルファ値として利用されるが、ここではいったんFFを入れる。TextOut関数やグラフ記述処理で書き換えが起こると0になることを利用して後の処理を行う。
		*(unsigned*)color = 0xFF000000;	
	}

	GetClientRect(hwndClockMain, &rcClock);


	if (!hdcClock) return;
//	FillClock(hwndClockMain, hdc, &rcClock, nBlink);
	FillClock();

	MakeFormat(s, pt, beat100, format);

	xclock = 0;
	yclock = 0;
	wclock = rcClock.right;
	hclock = rcClock.bottom;



	if (g_bTaskbarPosChanging)		//Added 20191206 TTTT
	{
		origWidthMainClock = wclock;
		origHeightMainClock = hclock;
		g_bTaskbarPosChanging = FALSE;

		if (b_DebugLog) {
			writeDebugLog_Win10("[tclock.c][DrawClockSub] origWidthMainClock = ", wclock);
			writeDebugLog_Win10("[tclock.c][DrawClockSub] origHeightMainClock = ", hclock);
		}
	}


	if (nAnalogClockUseFlag == ANALOG_CLOCK_USE)
	{
		if (nAnalogClockPos == ANALOG_CLOCK_POS_MIDDLE) {
			if(bGraph&&NetGraphScaleRecv>0&&(xclock+wclock)>0&&(yclock+hclock)>0)
				DrawGraph(hdcClock,xclock,yclock,wclock,hclock);
		} else {
			if(bGraph&&NetGraphScaleRecv>0&&(xclock+wclock)>0&&(yclock+hclock)>0)
				DrawGraph(hdcClock,xclock,yclock,wclock+sizeAClock.cx,hclock);
		}
	} else {
		if(bGraph&&NetGraphScaleRecv>0&&(xclock+wclock)>0&&(yclock+hclock)>0)
			DrawGraph(hdcClock,xclock,yclock,wclock,hclock);
	}


	//GetTextMetrics(hdcClock, &tm);
	//hf = tm.tmHeight - tm.tmInternalLeading;
	//p = s;
	//y = hf / 4 - tm.tmInternalLeading / 2 + yclock;


	if (nAnalogClockUseFlag == ANALOG_CLOCK_USE) 
	{
		if (nAnalogClockPos == ANALOG_CLOCK_POS_MIDDLE) {
			if(nTextPos == 1) {
				xcenter = xclock;
			} else if(nTextPos == 2) {
				xcenter = wclock + xclock - nShadowRange;
			} else {
				xcenter = wclock / 2 + xclock;
			}
		} else if (nAnalogClockPos == ANALOG_CLOCK_POS_LEFT) {
			if(nTextPos == 1) {
				xcenter = xclock + sizeAClock.cx;
			} else if(nTextPos == 2) {
				xcenter = wclock + xclock - nShadowRange;
			} else {
				xcenter = (wclock - sizeAClock.cx) / 2 + xclock + sizeAClock.cx;
			}
		} else {
			if(nTextPos == 1) {
				xcenter = xclock;
			} else if(nTextPos == 2) {
				xcenter = wclock + xclock - nShadowRange - sizeAClock.cx;
			} else {
				xcenter = (wclock - sizeAClock.cx) / 2 + xclock;
			}
		}
	} else {
		if(nTextPos == 1) {
			xcenter = xclock;
		} else if(nTextPos == 2) {
			xcenter = wclock + xclock - nShadowRange;
		} else {
			xcenter = wclock / 2 + xclock;
		}
	}


	LocalDrawAnalogClock(hdcClock, pt, xclock, yclock, wclock, hclock);

	//3.4.5.2 (2021/10/14) by TTTT
	//背景透過モードでアナログ時計の周りの黒を透過する。
	if (!fillbackcolor) {
		for (color = m_color_start; color < m_color_end; ++color) {
			if (*(unsigned*)color == 0x00000000) *(unsigned*)color = 0xFF000000;
		}
	}

	//グラフ類の描画 on hdcClock
	if (b_UseBarMeterBL && b_BatteryLifeAvailable)
	{
		DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, BarMeterBL_Right, BarMeterBL_Left,
			BarMeterBL_Bottom, BarMeterBL_Top, iBatteryLife, MyColorTT_BL(), b_BarMeterBL_Horizontal);
	}


	if (b_UseBarMeterCU)
	{
		DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, BarMeterCU_Right, BarMeterCU_Left,
			BarMeterCU_Bottom, BarMeterCU_Top, iCPUUsage, MyColorTT_CU(), b_BarMeterCU_Horizontal);
	}

	if (!b_BarMeterCU_Horizontal && b_UseBarMeterCore)
	{
		for (int i = 0; i < NumberBarMeterCore; i++)
			DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, (BarMeterCore_Right - i * BarMeterCore_Pitch), (BarMeterCore_Left - i * BarMeterCore_Pitch),
				BarMeterCore_Bottom, BarMeterCore_Top, CPUUsage[i], MyColorTT_Core(CPUUsage[i]), b_BarMeterCU_Horizontal);

	}



	if (b_UseBarMeterVL)
	{
		DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, BarMeterVL_Right, BarMeterVL_Left,
			BarMeterVL_Bottom, BarMeterVL_Top, iVolume, MyColorTT_VL(), b_BarMeterVL_Horizontal);
	}


	if (b_UseBarMeterNet)
	{
		if (b_BarMeterNet_LogGraph)
		{
			if (net[2] == 0)
			{
				NetBarMeterRecv = 0;
			}
			else
			{
				NetBarMeterRecv = (int)((LogDigit - 1 + log10(net[2]) - log10(NetGraphScaleRecv * 1024)) * 100 / LogDigit);
			}
			if (net[3] == 0)
			{
				NetBarMeterSend = 0;
			}
			else
			{
				NetBarMeterSend = (int)((LogDigit2 - 1 + log10(net[3]) - log10(NetGraphScaleSend * 1024)) * 100 / LogDigit2);
			}
		}
		else
		{
			NetBarMeterRecv = (int)(net[2] / (NetGraphScaleRecv * 1024) * 100);
			NetBarMeterSend = (int)(net[3] / (NetGraphScaleSend * 1024) * 100);
		}



		{
			DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, BarMeterNetSend_Right, BarMeterNetSend_Left,
				BarMeterNetSend_Bottom, BarMeterNetSend_Top, NetBarMeterSend, ColorBarMeterNetSend, b_BarMeterNet_Horizontal);
			DrawBarMeter2(hwndClockMain, hdcClock, wclock, hclock, BarMeterNetRecv_Right, BarMeterNetRecv_Left,
				BarMeterNetRecv_Bottom, BarMeterNetRecv_Top, NetBarMeterRecv, ColorBarMeterNetRecv, b_BarMeterNet_Horizontal);
		}
	}


	//文字の出力
	w = 0;
	GetTextMetrics(hdcClock, &tm);
	hf = tm.tmHeight - tm.tmInternalLeading;
	p = s;
	y = hf / 4 - tm.tmInternalLeading / 2 + yclock;

	while (*p)
	{
		sp = p;
		while (*p && *p != 0x0d) p++;
		if (*p == 0x0d) { *p = 0; p += 2; }
		if (*p == 0 && sp == s)
		{
			y = (hclock - tm.tmHeight) / 2 - tm.tmInternalLeading / 4 + yclock;
		}
		if (GetTextExtentPoint32(hdcClock, sp, strlen(sp), &sz) == 0)
		{
			sz.cx = (LONG)strlen(sp) * tm.tmAveCharWidth;
			sz.cy = tm.tmHeight;
		}
		if (w < sz.cx) w = sz.cx;

		if (!b_exist_DOWzone) {
			Textout_Tclock_Win10_2(xcenter, y + dvpos, sp, textshadow, textcol);
		}else{
			char *adr1, *adr2;
			adr1 = strchr(sp, 0x0f);
			adr2 = strchr(sp, 0x0e);
			if (adr1 != NULL) *adr1 = 0;
			if (adr2 != NULL) *adr2 = 0;
			SIZE size1, size2, size3;
			int x_temp;

			x_temp = xcenter;



			if (adr1 != NULL)
			{
				if (adr2 != NULL)
				{
					if (GetTextExtentPoint32(hdcClock, sp, strlen(sp), &size1) != 0)
					{
						if (GetTextExtentPoint32(hdcClock, adr1 + 1, strlen(adr1 + 1), &size2) != 0)
						{
							if (GetTextExtentPoint32(hdcClock, adr2 + 1, strlen(adr2 + 1), &size3) != 0)
							{
								if (nTextPos == 1) {
									x_temp = xcenter;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp += size1.cx;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
									x_temp += size2.cx;
									sp = adr2 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
								}
								else if (nTextPos == 2) {
									x_temp = xcenter - size2.cx - size3.cx;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp += size2.cx;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
									x_temp += size3.cx;
									sp = adr2 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
								}
								else {
									x_temp = xcenter - (size2.cx + size3.cx) / 2  - nShadowRange;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp = xcenter + (size1.cx - size3.cx) / 2 - nShadowRange;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
									x_temp = xcenter + (size1.cx + size2.cx) / 2 - nShadowRange;
									sp = adr2 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
								}
							}
						}
					}
				}
				else {
					if (GetTextExtentPoint32(hdcClock, sp, strlen(sp), &size1) != 0)
					{
						if (GetTextExtentPoint32(hdcClock, adr1 + 1, strlen(adr1 + 1), &size2) != 0)
						{
								if (nTextPos == 1) {
									x_temp = xcenter;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp += size1.cx;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
								}
								else if (nTextPos == 2) {
									x_temp = xcenter - size2.cx;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp += size2.cx;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
								}
								else {
									x_temp = xcenter - size2.cx / 2 - nShadowRange;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
									x_temp = xcenter + size1.cx / 2 - nShadowRange;
									sp = adr1 + 1;
									Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol_DoWzone);
								}
						}
					}
				}
			}
			else if (adr2 != 0)
			{
				if (GetTextExtentPoint32(hdcClock, sp, strlen(sp), &size1) != 0)
				{
					if (GetTextExtentPoint32(hdcClock, adr2 + 1, strlen(adr2 + 1), &size3) != 0)
					{
						if (nTextPos == 1) {
							x_temp = xcenter;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
							x_temp += size1.cx;
							sp = adr2 + 1;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
						}
						else if (nTextPos == 2) {
							x_temp = xcenter - size3.cx;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
							x_temp += size3.cx;
							sp = adr2 + 1;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
						}
						else {
							x_temp = xcenter - size3.cx / 2 - nShadowRange;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
							x_temp = xcenter + size1.cx / 2 - nShadowRange;
							sp = adr2 + 1;
							Textout_Tclock_Win10_2(x_temp, y + dvpos, sp, textshadow, textcol);
						}
					}
				}
			}
			else
			{
				Textout_Tclock_Win10_2(xcenter, y + dvpos, sp, textshadow, textcol);
			}

		}

		y += hf; if (*p) y += 2 + dlineheight;
	}

	//3.4.5.2 (2021/10/14) by TTTT
	//この時点で、非透過の場合はhdcClockに転送すべき画像が出来上がっており、すべての画素でrgbReserved = 0になっているので、それを255にすればよい。
	//背景透過の場合は、以下のプロセスになる。
	//hdcClock(ビットマップ先頭アドレス:m_color_start) 背景はテーマ背景色+rgbReserved=255、グラフ書き込んだところだけrgbReservedが0になっている。
	//hdcClock_work(ビットマップ先頭アドレス:m_color_work_start)背景は黒+rgbReserved=255、文字書き込んだところがrgbReservedが0になっている。
	//rが0でないところはtextcol, gが0でないところはtextcol_WoDzone, bが0でないところはtextshadowの色をつけるべきところ。
	//r, g, bをαとみなして、color_workのデータからcolorのデータを作っていく。


	if (fillbackcolor) {	//背景非透過の場合
		for (color = m_color_start; color < m_color_end; ++color) {
			color->rgbReserved = 255;
		}
	}
	else{			//背景透過の場合
		unsigned channel;
		BYTE temp_alpha;
		BYTE textcol_r, textcol_g, textcol_b;
		textcol_r = GetRValue(textcol);
		textcol_g = GetGValue(textcol);
		textcol_b = GetBValue(textcol);

		BYTE textcol_DoWzone_r, textcol_DoWzone_g, textcol_DoWzone_b;
		textcol_DoWzone_r = GetRValue(textcol_DoWzone);
		textcol_DoWzone_g = GetGValue(textcol_DoWzone);
		textcol_DoWzone_b = GetBValue(textcol_DoWzone);

		BYTE textshadow_r, textshadow_g, textshadow_b;
		textshadow_r = GetRValue(textshadow);
		textshadow_g = GetGValue(textshadow);
		textshadow_b = GetBValue(textshadow);

		for (color = m_color_start, color_work = m_color_work_start; color<m_color_end; ++color, ++color_work) {
			//BYTE temp_rgbReserved = color->rgbReserved;
			if (color->rgbReserved == 255) {								//グラフドットがないところ
				if (color_work->rgbRed > 10) {
					//			*(unsigned*)color = ((unsigned)(color_work->rgbRed)) << 24 | (textcol & 0x0000FF00) | ((textcol & 0xFF) << 16) | ((textcol >> 16) & 0xFF);
					temp_alpha = color_work->rgbRed;
					channel = textcol_r * temp_alpha / 255;
					color->rgbRed = (channel>255 ? 255 : (BYTE)channel);
					channel = textcol_g * temp_alpha / 255;
					color->rgbGreen = (channel>255 ? 255 : (BYTE)channel);
					channel = textcol_b * temp_alpha / 255;
					color->rgbBlue = (channel>255 ? 255 : (BYTE)channel);
					color->rgbReserved = temp_alpha;
				}
				else if (color_work->rgbGreen > 10) {
					//			*(unsigned*)color = ((unsigned)(color_work->rgbGreen)) << 24 | (textcol_DoWzone & 0x0000FF00) | ((textcol_DoWzone & 0xFF) << 16) | ((textcol_DoWzone >> 16) & 0xFF);
					temp_alpha = color_work->rgbGreen;
					channel = textcol_DoWzone_r * temp_alpha / 255;
					color->rgbRed = (channel>255 ? 255 : (BYTE)channel);
					channel = textcol_DoWzone_g * temp_alpha / 255;
					color->rgbGreen = (channel>255 ? 255 : (BYTE)channel);
					channel = textcol_DoWzone_b * temp_alpha / 255;
					color->rgbBlue = (channel>255 ? 255 : (BYTE)channel);
					color->rgbReserved = temp_alpha;
				}
				else if (color_work->rgbBlue > 10) {
					//			*(unsigned*)color = ((unsigned)(color_work->rgbBlue)) << 24 | (textshadow & 0x0000FF00) | ((textshadow & 0xFF) << 16) | ((textshadow >> 16) & 0xFF);
					temp_alpha = color_work->rgbBlue;
					channel = textshadow_r * temp_alpha / 255;
					color->rgbRed = (channel>255 ? 255 : (BYTE)channel);
					channel = textshadow_g * temp_alpha / 255;
					color->rgbGreen = (channel>255 ? 255 : (BYTE)channel);
					channel = textshadow_b * temp_alpha / 255;
					color->rgbBlue = (channel>255 ? 255 : (BYTE)channel);
					color->rgbReserved = temp_alpha;

				}
				else {
					*(unsigned*)color = 0x00000000;
				}
			}
			else{
				color->rgbReserved = 255;
			}
		}
	}

	xsrc = 0; ysrc = 0; wsrc = wclock; hsrc = hclock;


	if(nBlink == 0 || (nBlink % 2))
	{
		//202110月時点のWindowsではrgbReservedを透明度(255:非透明, 0:透明,ただしクリア)としてhdcにコピーしたら、そののちはαブレンドしてくれる。
		//ただしr, g, bの値もあらかじめαをかけておく必要がある。
		//Alphaブレンドの設定のAC_SRC_ALPHAのところの説明が該当する。
		//https://docs.microsoft.com/ja-jp/windows/win32/api/wingdi/ns-wingdi-blendfunction?redirectedfrom=MSDN

		BitBlt(hdc, 0, 0, widthMainClockFrame, heightMainClockFrame, hdcClock, 0, 0, SRCCOPY);
	}
	else
	{
		BitBlt(hdc, 0, 0, widthMainClockFrame, heightMainClockFrame, hdcClock, 0, 0, NOTSRCCOPY);
	}




	HDC hdcSub = NULL;

	for (int i = 0; i < numberSubClk; i++) {
		if (bEnableDrawSubClk[i]) {
			hdcSub = NULL;
			hdcSub = GetDC(hwndClockSubClk[i]);		//サブディスプレイの時計が存在するとhdcSubが存在することになる。
			if (hdcSub != NULL)
			{
				SetStretchBltMode(hdcSub, HALFTONE);	//HALFTONEにするとグラフ等の色が薄くなるがきれい。COLORONCOLORはきれいに表示できないケースあり。

				//サブウィンドウクロックには画面外領域をコピーしないようにFrameのサイズで転送する(3.5.0.1の時点ではhdcClockのサイズははみ出てないので大丈夫だが)。
				if (nBlink == 0 || (nBlink % 2))
				{
					StretchBlt(hdcSub, 0, 0, widthSubClock[i], heightSubClock[i], hdcClock, xsrc, ysrc, widthMainClockFrame, heightMainClockFrame, SRCCOPY);
				}else {
					StretchBlt(hdcSub, 0, 0, widthSubClock[i], heightSubClock[i], hdcClock, xsrc, ysrc, widthMainClockFrame, heightMainClockFrame, NOTSRCCOPY);
				}
				ReleaseDC(hwndClockSubClk[i], hdcSub);
			}
			else {
				if (b_DebugLog)	writeDebugLog_Win10("[tclock.c][DrawClockSub] Clock on SubDisplay Disabled !! ID = ", i);
				bEnableDrawSubClk[i] = FALSE;
			}
		}
	}




	//決してここでRedrawTClockを実行してはいけない！ -> コード内で無限ループになる！！
	//決してここでRedrawMainTaskbarを実行してはいけない！ -> Windows経由で無限ループになる！！

//NG!!!!!	RedrawMainTaskbar();	
}


/*------------------------------------------------
paint graph, added by TTTT
--------------------------------------------------*/
void DrawBarMeter(HWND hwnd, HDC hdc, int wclock, int hclock, int bar_right, int bar_left, int value, COLORREF color)
{
	//hwndは使われていない。
	RECT barRect;
	HBRUSH hbr;

	if (bar_left > wclock || bar_right > wclock || bar_left <= bar_right || value < 0) return;
	if (value > 100) value = 100;
	barRect.bottom = hclock;
	barRect.top = (hclock * (100 - value)) / 100;
	barRect.left = wclock - bar_left;
	barRect.right = wclock - bar_right;

	hbr = CreateSolidBrush(color);
	FillRect(hdc, &barRect, hbr);
	DeleteObject(hbr);
}




/*------------------------------------------------
paint graph, added by TTTT
--------------------------------------------------*/
void DrawBarMeter2(HWND hwnd, HDC hdc, int wclock, int hclock, int bar_right, int bar_left, int bar_bottom, int bar_top, int value, COLORREF color, BOOL b_Horizontal)
{
	//hwndは使われていない。

	RECT barRect;
	HBRUSH hbr;
	int scale;

	if (bar_left > wclock || bar_right > wclock || bar_left <= bar_right) return;
	if (bar_top >= 0 && bar_top < bar_bottom) return;
	if (value < 0) return;

	if (value > 100) value = 100;

	barRect.bottom = hclock - bar_bottom - offsetBottomOfMeter;

	if (bar_top < 0)
	{
		barRect.top = 0;
	}
	else
	{
		barRect.top = hclock - bar_top;
	}
	barRect.left = wclock - bar_left;
	barRect.right = wclock - bar_right;

	if (b_Horizontal)
	{
		scale = barRect.left - barRect.right;
		barRect.right = barRect.left - (scale * value / 100);
	}
	else
	{
		scale = barRect.bottom - barRect.top;
		barRect.top = barRect.bottom - (scale * value / 100);
	}

	hbr = CreateSolidBrush(color);
	FillRect(hdc, &barRect, hbr);
	DeleteObject(hbr);
}

/*------------------------------------------------
  paint graph
--------------------------------------------------*/
void DrawGraph(HDC hdc, int xclock, int yclock, int wclock, int hclock)
{
	int i, x, y, d;
	double one_dots = 0, one_dotr = 0;
	int graphSizeS;
	int graphSizeR;

	getGraphVal();

	//int LogDigit = 4;

	if(GraphL>wclock||GraphT>hclock)return;
	xclock+=GraphL;
	yclock+=GraphT;
	wclock-=GraphL+GraphR;
	hclock-=GraphT+GraphB + offsetBottomOfMeter;
	if(wclock > 0 && hclock > 0)
	{
		HPEN penSR = CreatePen(PS_SOLID,1,ColSR);
		HPEN penR = CreatePen(PS_SOLID,1,ColRecv);
		HPEN penS = CreatePen(PS_SOLID,1,ColSend);
		HGDIOBJ oldPen=SelectObject(hdc,(HGDIOBJ)penSR);

		// Network
		if (graphMode == 1)
		{
			one_dotr = (double)(NetGraphScaleRecv  * 1024);
			one_dots = (double)(NetGraphScaleSend * 1024);
		}
		// CPU
		else if (graphMode == 2)
		{
			one_dotr = (double)100;
			one_dots = (double)100;
		}



		// 横方向
		if ( bGraphTate )
		{
			one_dotr /= (double)(xclock + wclock);
			one_dots /= (double)(xclock + wclock);
			MoveToEx(hdc, (xclock + wclock) - 1, yclock, NULL);
			for(y = yclock;y < (yclock + hclock);y++)
			{
				if (bReverseGraph)
				{
					i = y - yclock;
					d = -1;
				}
				else
				{
					i = (yclock+hclock)-y-1;
					d = 1;
				}
				if(i >= 0 && i < MAXGRAPHLOG)
				{
					if(bLogGraph == TRUE && graphMode == 1)	//NET, Log
					{
						graphSizeS = (int)((LogDigit2 - 1 + log10(sendlog[i]) - log10(NetGraphScaleSend * 1024)) * wclock / LogDigit2);
						graphSizeR = (int)((LogDigit - 1 + log10(recvlog[i]) - log10(NetGraphScaleRecv * 1024)) * wclock / LogDigit);
					}
					else
					{
						graphSizeS = (int)(sendlog[i] / one_dots);
						graphSizeR = (int)(recvlog[i] / one_dotr);
					}

					if(GraphType == 1)	//棒グラフ
					{
						MoveToEx(hdc, (xclock + wclock) - 1, y, NULL);
						if(graphSizeR > graphSizeS)
						{
							if(graphSizeS > 0)
							{
								SelectObject(hdc, (HGDIOBJ)penSR);
								LineTo(hdc, max((xclock + wclock) - graphSizeS, 0), y);
							}
							if(graphSizeR > graphSizeS)
							{
								SelectObject(hdc, (HGDIOBJ)penR);
								LineTo(hdc, max((xclock + wclock) - graphSizeR, 0), y);
							}
						}
						else
						{
							if(graphSizeR > 0)
							{
								SelectObject(hdc,(HGDIOBJ)penSR);
								LineTo(hdc, max((xclock + wclock) - graphSizeR, 0), y);
							}
							if(graphSizeR < graphSizeS)
							{
								SelectObject(hdc,(HGDIOBJ)penS);
								LineTo(hdc, max((xclock + wclock) - graphSizeS, 0), y);
							}
						}
					}
					else if(GraphType==2)	//折れ線
					{
						if(i<MAXGRAPHLOG)
						{
							if(graphMode==1)	//Net
							{
								int SendThis;
								int RecvThis;
								int SendPrev;
								int RecvPrev;

								if (bLogGraph)
								{
									if (sendlog[i] == 0) SendThis = 0;
									else SendThis = (int)((LogDigit2 - 1 + log10(sendlog[i]) - log10(NetGraphScaleSend * 1024)) * wclock / LogDigit2);
									if (recvlog[i] == 0) RecvThis = 0;
									else RecvThis = (int)((LogDigit - 1 + log10(recvlog[i]) - log10(NetGraphScaleRecv * 1024)) * wclock / LogDigit);
									if (sendlog[i+1] == 0) SendPrev = 0;
									else SendPrev = (int)((LogDigit2 - 1 + log10(sendlog[i + 1]) - log10(NetGraphScaleSend * 1024)) * wclock / LogDigit2);
									if (recvlog[i+1] == 0) RecvPrev = 0;
									else RecvPrev = (int)((LogDigit - 1 + log10(recvlog[i + 1]) - log10(NetGraphScaleRecv * 1024)) * wclock / LogDigit);
								}
								else
								{
									SendThis = (int)(sendlog[i] / (NetGraphScaleSend * 1024) * wclock);
									RecvThis = (int)(recvlog[i] / (NetGraphScaleRecv * 1024) * wclock);
									SendPrev = (int)(sendlog[i + 1] / (NetGraphScaleSend * 1024) * wclock);
									RecvPrev = (int)(recvlog[i + 1] / (NetGraphScaleRecv * 1024) * wclock);
								}


								MoveToEx(hdc,xclock+wclock- max(SendPrev,0),y-d,NULL);
								SelectObject(hdc,(HGDIOBJ)penS);
								LineTo(hdc,xclock+wclock - max(SendThis,0),y);
								MoveToEx(hdc,xclock+wclock- max(RecvPrev,0),y-d,NULL);
								SelectObject(hdc,(HGDIOBJ)penR);
								LineTo(hdc,xclock+wclock- max(RecvThis,0),y);
							}
							else if(graphMode==2)	//CPU
							{
								MoveToEx(hdc,max((xclock+wclock)-(int)(recvlog[i+1]/one_dotr),0),y-d,NULL);
								if(sendlog[i]==recvlog[i])
								{
									SelectObject(hdc,(HGDIOBJ)penSR);
								}
								else
								{
									SelectObject(hdc,(HGDIOBJ)penR);
								}
								LineTo(hdc,max((xclock+wclock)-(int)(recvlog[i]/one_dotr),0),y);
							}
						}
					}
				}
			}
		}

    // 縦方向
		else
		{
			one_dotr/=(double)(yclock+hclock);
			one_dots/=(double)(yclock+hclock);
			for(x = xclock;x < (xclock + wclock);x++)
			{
				if (bReverseGraph)
				{
					i = x - xclock;
					d = -1;
				}
				else
				{
					i = (xclock+wclock)-x-1;
					d = 1;
				}
				if(i >= 0 && i < MAXGRAPHLOG)
				{
					if(bLogGraph == TRUE && graphMode == 1)
					{

						graphSizeS = (int)((LogDigit2 - 1 + log10(sendlog[i]) - log10(NetGraphScaleSend * 1024)) * hclock / LogDigit2);
						graphSizeR = (int)((LogDigit - 1 + log10(recvlog[i]) - log10(NetGraphScaleRecv * 1024)) * hclock / LogDigit);
					}
					else
					{
						graphSizeS = (int)(sendlog[i] / one_dots);
						graphSizeR = (int)(recvlog[i] / one_dotr);
					}

					if(GraphType==1)	//棒グラフ
					{
						MoveToEx(hdc, x, (yclock + hclock) - 1,NULL);
						if(recvlog[i]>sendlog[i])
						{
							if(graphSizeS > 0)
							{
								SelectObject(hdc,(HGDIOBJ)penSR);
								LineTo(hdc, x, max((yclock + hclock) - graphSizeS, 0));
							}
							if(graphSizeR > graphSizeS)
							{
								SelectObject(hdc,(HGDIOBJ)penR);
								LineTo(hdc, x, max((yclock + hclock) - graphSizeR, 0));
							}
						}
						else
						{
							if(graphSizeR > 0)
							{
								SelectObject(hdc, (HGDIOBJ)penSR);
								LineTo(hdc, x, max((yclock + hclock) - graphSizeR, 0));
							}
							if(graphSizeR < graphSizeS)
							{
								SelectObject(hdc,(HGDIOBJ)penS);
								LineTo(hdc, x, max((yclock + hclock) - graphSizeS, 0));
							}
						}
					}
					else if(GraphType==2)	//折れ線
					{
						if(i<MAXGRAPHLOG)
						{
							if(graphMode==1)	//Net
							{
								int SendThis;
								int RecvThis;
								int SendPrev;
								int RecvPrev;

								if (bLogGraph)
								{
									if (sendlog[i] == 0) SendThis = 0;
									else SendThis = (int)((LogDigit2 - 1 + log10(sendlog[i]) - log10(NetGraphScaleSend * 1024)) * hclock / LogDigit2);
									if (recvlog[i] == 0) RecvThis = 0;
									else RecvThis = (int)((LogDigit - 1 + log10(recvlog[i]) - log10(NetGraphScaleRecv * 1024)) * hclock / LogDigit);
									if (sendlog[i + 1] == 0) SendPrev = 0;
									else SendPrev = (int)((LogDigit2 - 1 + log10(sendlog[i + 1]) - log10(NetGraphScaleSend * 1024)) * hclock / LogDigit2);
									if (recvlog[i + 1] == 0) RecvPrev = 0;
									else RecvPrev = (int)((LogDigit - 1 + log10(recvlog[i + 1]) - log10(NetGraphScaleRecv * 1024)) * hclock / LogDigit);
								}
								else
								{
									SendThis = (int)(sendlog[i] / (NetGraphScaleSend * 1024) * hclock);
									RecvThis = (int)(recvlog[i] / (NetGraphScaleRecv * 1024) * hclock);
									SendPrev = (int)(sendlog[i+1] / (NetGraphScaleSend * 1024) * hclock);
									RecvPrev = (int)(recvlog[i+1] / (NetGraphScaleRecv * 1024) * hclock);
								}
								MoveToEx(hdc, x - d, yclock + hclock - max(SendPrev, 0), NULL);
								SelectObject(hdc, (HGDIOBJ)penS);
								LineTo(hdc, x, yclock + hclock - max(SendThis, 0));
								MoveToEx(hdc, x - d, yclock + hclock - max(RecvPrev, 0), NULL);
								SelectObject(hdc, (HGDIOBJ)penR);
								LineTo(hdc, x, yclock + hclock - max(RecvThis, 0));
							}
							else if(graphMode==2)	//CPU
							{
								MoveToEx(hdc,x-d,max((yclock+hclock)-(int)(recvlog[i+1]/one_dotr),0),NULL);
								if(sendlog[i]==recvlog[i])
								{
									SelectObject(hdc,(HGDIOBJ)penSR);
								}
								else
								{
									SelectObject(hdc,(HGDIOBJ)penR);
								}
								LineTo(hdc,x,max((yclock+hclock)-(int)(recvlog[i]/one_dotr),0));
							}
						}
					}
				}
			}
		}
		SelectObject(hdc,oldPen);
		DeleteObject(penSR);
		DeleteObject(penR);
		DeleteObject(penS);
	}
}

void getGraphVal()
{
	int i;
	extern double net[];

	if (graphMode == 1)
	{

		for(i=MAXGRAPHLOG-1;i>=0;i--)
		{
			sendlog[i+1]=sendlog[i];
			recvlog[i+1]=recvlog[i];
		}
		sendlog[0] = net[3];
		recvlog[0] = net[2];


	}
	else if (graphMode == 2)
	{
		int cpu_u;
		for(i=MAXGRAPHLOG-1;i>=0;i--)
		{
			sendlog[i+1]=sendlog[i];
			recvlog[i+1]=recvlog[i];
		}
		cpu_u = bGetSysRes ? iCPUUsage : CpuMoni_get();
		if (cpu_u >= cpuHigh)
		{
			recvlog[0]=(double)cpu_u;
			sendlog[0]=cpuHigh;
		}
		else
		{
			recvlog[0]=(double)cpu_u;
			sendlog[0]=(double)cpu_u;
		}
	}
	bGraphRedraw = TRUE;
}

/*------------------------------------------------
  paint background of clock
--------------------------------------------------*/
//void FillClock(HWND hwnd, HDC hdc, RECT *prc, int nblink)
void FillClock()
{
	//hwndは使われていない。
	HBRUSH hbr;
	COLORREF col;
//	HDC hdcTemp;
//	BITMAP bmp;





	if (!fillbackcolor)
	{
		//以前はここに時計背景をhdcClockに収容してその上に書き込むコードがあったが、2021年10月時点で機能しないものになっている。
		//Windowsのタスクバー構造が完全に変わっていてその方式が復活する可能性はないので、削除
		//透明化は、時計のビットマップを透過合成対応にして実現している。
	}
	else if (colback == colback2)
	{
		col = colback;
		if(col & 0x80000000) col = GetSysColor(col & 0x00ffffff);
		hbr = CreateSolidBrush(col);
		FillRect(hdcClock, &rectMainClock, hbr);
		DeleteObject(hbr);
	}
	else
	{
		COLORREF col2;

		col = colback;
		if(col & 0x80000000) col = GetSysColor(col & 0x00ffffff);
		col2 = colback2;
		if(col2 & 0x80000000) col2 = GetSysColor(col2 & 0x00ffffff);

		GradientFillClock(col, col2, grad);
	}
}





// TClockの中身のサイズを計算
// OnCalcRectのオリジナルコードを引継ぎ
// 時計エリアより小さい場合の補正を含まない。正しい描画領域を決めるには
// CalcMainClockSize()を呼ぶこと。この関数も呼ばれた上で、時計エリアに合うように適切な補正がなされる。
// この関数だけ呼ぶと、widthMainClockContent, heightMainClockContentはタスクバー幅(縦タスクバー)やタスクバー高さ(横タスクバー)より小さくなってしまうので、
// 直接呼ばないこと。
void CalcMainClockContentSize(void)
{
	SYSTEMTIME t;
	int beat100 = 0;
	LONG w, h;
	HDC hdc;
	HGDIOBJ hOldFont = NULL;
	TEXTMETRIC tm;
	char s[1024], *p, *sp;
	SIZE sz;
	int hf;


	hdc = GetDC(hwndClockMain);

	if (hFon) hOldFont = SelectObject(hdc, hFon);	//ここでフォントを設定している。
	GetTextMetrics(hdc, &tm);

	GetDisplayTime(&t, nDispBeat ? (&beat100) : NULL);
	MakeFormat(s, &t, beat100, format);

	p = s; w = 0; h = 0;
	hf = tm.tmHeight - tm.tmInternalLeading;
	while (*p)
	{
		sp = p;
		while (*p && *p != 0x0d) p++;
		if (*p == 0x0d) { *p = 0; p += 2; }
		if (GetTextExtentPoint32(hdc, sp, strlen(sp), &sz) == 0)
			sz.cx = (LONG)strlen(sp) * tm.tmAveCharWidth;
		if (w < sz.cx) w = sz.cx;
		h += hf; if (*p) h += 2 + dlineheight;
	}

	if (nAnalogClockUseFlag == ANALOG_CLOCK_USE)
	{
		if (nAnalogClockPos != ANALOG_CLOCK_POS_MIDDLE) {
			w += sizeAClock.cx;
		}
	}

	w += tm.tmAveCharWidth * 2;
	w += dwidth;
	//if (w > iClockWidth)iClockWidth = w;
	//h += hf / 2 + dheight + dclkvpos;
	h += hf / 2 + dheight;
	if (bClockShadow)
	{
		h += nShadowRange; w += nShadowRange;
	}
	if (h < 4) h = 4;

//	if (hFon) SelectObject(hdc, hOldFont);		//この先ずっとTClockが稼働するので、戻さなくてよい。
	ReleaseDC(hwndClockMain, hdc);


	if (b_DebugLog) {
		writeDebugLog_Win10("[tclock.c][CalcMainClockContentSize] Clock Content Width = ", w);
		writeDebugLog_Win10("[tclock.c][CalcMainClockContentSize] Clock Content Height = ", h);
	}

	//タスクバー領域より小さくてもそのまま返す。
	widthMainClockContent = w;
	heightMainClockContent = h;
}



// TClockの収容フレームサイズを計算
// CalcMainClockCOntetSizeを呼ぶので
// 時計のコンテンツのサイズも計算することになる。
// タスクバー方向の判定も行う。
// FrameはContentと同じか小さい
// 縦型の場合は高さは常に同じで、幅はContentの右が切れる(Frameは左から切れ目まで)可能性がある。
// 横型の場合は幅は常に同じで、下はContentの下が切れる(Frameは上から切れ目まで)可能性がある。
void CalcMainClockSize(void)
{

	g_bVertTaskbar = IsVertTaskbar(hwndTaskBarMain);
	CalcMainClockContentSize();

	RECT tempRect;
	GetWindowRect(hwndTaskBarMain, &tempRect);

	if (g_bVertTaskbar) {
		widthMainClockFrame = tempRect.right - tempRect.left;
		if (widthMainClockContent < widthMainClockFrame) widthMainClockContent = widthMainClockFrame;	//縦タスクバーより幅が狭い場合には幅をタスクバーにあわせる。
		heightMainClockFrame = heightMainClockContent;
	}
	else {
		widthMainClockFrame = widthMainClockContent;
		heightMainClockFrame = tempRect.bottom - tempRect.top;
		if (heightMainClockContent < heightMainClockFrame) heightMainClockContent = heightMainClockFrame; //横タスクバーより高さが狭い場合には高さをタスクバーにあわせる
	}

	if (b_DebugLog) {
		writeDebugLog_Win10("[tclock.c][CalcMainClockContentSize] Clock Frame Width = ", widthMainClockFrame);
		writeDebugLog_Win10("[tclock.c][CalcMainClockContentSize] Clock Frame Height = ", heightMainClockFrame);
	}

}




/*------------------------------------------------
　時計に必要なサイズを返す
　戻り値：上位WORD 高さ　下位WORD 幅
  Ver3.5.0.1で、CalcMainClockSizeを利用した処理に移行したので廃止
  一応、しばらくコメントアウトで残しておく。
--------------------------------------------------*/
//LRESULT OnCalcRect(void)
//{
//	SYSTEMTIME t;
//	int beat100 = 0;
//	LONG w, h;
//	HDC hdc;
//	HGDIOBJ hOldFont = NULL;
//	TEXTMETRIC tm;
//	char s[1024], *p, *sp;
//	//COLORREF s_col[1024];
//	SIZE sz;
//	int hf;
//
//	if(!(GetWindowLongPtr(hwndClockMain, GWL_STYLE) & WS_VISIBLE)) return 0;
//
//	RECT tempRect;
//	GetWindowRect(hwndClockMain, &tempRect);
////	origWidthMainClock = tempRect.right - tempRect.left;
//	origHeightMainClock = tempRect.bottom - tempRect.top;
//
//
//	hdc = GetDC(hwndClockMain);
//
//	if(hFon) hOldFont = SelectObject(hdc, hFon);
//	GetTextMetrics(hdc, &tm);
//
//	GetDisplayTime(&t, nDispBeat?(&beat100):NULL);
//	MakeFormat(s, &t, beat100, format);
//
//
//	p = s; w = 0; h = 0;
//	hf = tm.tmHeight - tm.tmInternalLeading;
//	while(*p)
//	{
//		sp = p;
//		while(*p && *p != 0x0d) p++;
//		if(*p == 0x0d) { *p = 0; p += 2; }
//		if(GetTextExtentPoint32(hdc, sp, strlen(sp), &sz) == 0)
//			sz.cx = (LONG)strlen(sp) * tm.tmAveCharWidth;
//		if(w < sz.cx) w = sz.cx;
//		h += hf; if(*p) h += 2 + dlineheight;
//	}
//
//
//	if (nAnalogClockUseFlag == ANALOG_CLOCK_USE) 
//	{
//		if (nAnalogClockPos != ANALOG_CLOCK_POS_MIDDLE) {
//			w += sizeAClock.cx;
//		}
//	}
//
//
//	w += tm.tmAveCharWidth * 2;
//	w += dwidth;
//	if(w > iClockWidth)iClockWidth = w;
//	//h += hf / 2 + dheight + dclkvpos;
//	h += hf / 2 + dheight;
//	if(bClockShadow)
//	{
//		h += nShadowRange; w += nShadowRange;
//	}
//	if(h < 4) h = 4;
//
//	if(hFon) SelectObject(hdc, hOldFont);
//	ReleaseDC(hwndClockMain, hdc);
//
//
//	if (b_DebugLog) {
//		writeDebugLog_Win10("[tclock.c][OnCalcRect] Calculated Clock Width w = ", w);
//		writeDebugLog_Win10("[tclock.c][OnCalcRect] Calculated Clock Width h = ", h);
//	}
//
//	if (!g_bVertTaskbar && (origHeightMainClock > h)) {
//		h = origHeightMainClock;
//	}
//
//	if (b_DebugLog) {
//		writeDebugLog_Win10("[tclock.c][OnCalcRect] Determined Clock Height h = ", h);
//	}
//
//	//Added 20191207 TTTT to make maters and bars on the bottom of horizontal clock
//	if (g_bVertTaskbar)
//	{
//		offsetBottomOfMeter = 0;
//	}
//	else
//	{
//		GetWindowRect(hwndTrayMain, &tempRect);
//		offsetBottomOfMeter = h - (tempRect.bottom - tempRect.top);
//		if (offsetBottomOfMeter < 0) offsetBottomOfMeter = 0;
//	}
//
//	return (h << 16) + w;			//Reactivate to work with vertical taskbaer 20191206 TTTT
//}


void UpdateSysRes(BOOL bsysres, BOOL bbattery, BOOL bmem, BOOL bmb, BOOL bpermon, BOOL bnet, BOOL bhdd, BOOL bcpuc, BOOL bvol)
{
	int i;



	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] UpdateSysRes called. ", 999);

	if (bTimerAdjust_SysInfo)
	{
		bTimerAdjust_SysInfo = FALSE;
		SetTimer(hwndClockMain, IDTIMERDLL_SYSINFO, TimerCountForSec, NULL);
	}

	if(bbattery)
	{
		iBatteryLife = GetBatteryLifePercent();

		if (iBatteryLife > 100 && b_BatteryLifeAvailable)
		{
			b_BatteryLifeAvailable = FALSE;
			SetMyRegLong("Status_DoNotEdit", "BatteryLifeAvailable", 0);
			if (b_UseBarMeterBL)
			{
				b_UseBarMeterBL = FALSE;
				SetMyRegLong("BarMeter", "UseBarMeterBL", 0);
			}
			bGetBattery = FALSE;
		}
	}

	if(bcpuc)
	{
		UpdateCpuClock();
	}

	if(bmem)
	{
		msMemory.dwLength = sizeof(msMemory);
		GlobalMemoryStatusEx(&msMemory);
	}

	if(bvol)
	{
		getMasterVolume_Win10();
	}


	if(bpermon)
	{
		PerMoni_get();
	}

	if(bnet)
	{
		Net_get();
	}

	if(bhdd)
	{
		Hdd_get();
	}

	if(bsysres)
	{
		iCPUUsage = CpuMoni_get(); // cpu.c
	}

	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] UpdateSysRes finished. ", 999);


}



void OntimerCheckNetStat_Win10(HWND hwnd)
{
	int i;

	//if (b_DebugLog) writeDebugLog_Win10("[tclock.c] OntimerCheckNetStat_Win10 called. ", 999);

	if (bTimerAdjust_NetStat)
	{
		bTimerAdjust_NetStat = FALSE;
		SetTimer(hwndClockMain, IDTIMERDLL_CHECKNETSTAT, TimerCountForSec, NULL);
		//if (b_DebugLog) writeDebugLog_Win10("[OntimerCheckNetStat_Win10] IDTIMERDLL_CHECKNETSTAT was Adjusted with offset(ms) :", OFFSETMS_TIMER_NETSTAT);
	}


	if (!b_CompactMode)
	{
		chkInternetConnectionProfile_Win10(); // replaced by TTTT to check whether this chkDataPlanUsage_OK is needed or not.
	}

}



//added by TTTT 20200914
void GetTimeZoneBias_Win10(void)
{
	TIME_ZONE_INFORMATION tzi;
	DWORD dw;

	memset(&tzi, 0, sizeof(tzi));
	dw = GetTimeZoneInformation(&tzi);
	if (dw == TIME_ZONE_ID_STANDARD)
	{
		currentTimeZoneBiasMin = (int)tzi.StandardBias;
	}
	if (dw == TIME_ZONE_ID_DAYLIGHT)
	{
		currentTimeZoneBiasMin = (int)tzi.DaylightBias;
	}
	else {
		currentTimeZoneBiasMin = (int)tzi.Bias;
	}


//	currentTimeZoneBiasMin = (int)tzi.Bias;
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][GetTimeZoneBias_Win10] currentTimeZoneBiasMin = ", currentTimeZoneBiasMin);

}


// Added by TTTT for Win10AU (WIN10RS1) compatibility
// Imported from TClockLight-tclocklight-kt160911, dll/Wndproc.c
/*------------------------------------------------
subclass procedure of the tray
--------------------------------------------------*/
LRESULT CALLBACK SubclassTrayProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
	//このコード内ではhwndがhwndTrayMainであり、他の多くの場合(hwnd=hwndClockMain)と異なるなので注意すること！
	//タスクトレイはメインのタスクバーにしか存在しないので、それ以外には使えないコールバック関数になっている。

	if (b_DebugLog) {
//		if ((message != 20) && (message != 70) && (message != 78) && (message != 792) && (message != 1028))
			//20:	WM_PAINT 
			//70:	WM_WINDOWPOSCHANGING 
			//78: 	WM_NOTIFY
			//132	WM_NCHITTEST
			//1028:
			//1124: USER + 100
		{
//			writeDebugLog_Win10("[tclock.c][SubclassTrayProc] Window Message was recevied, message = ", message);
		}
	}

	switch (message)
	{
	case (WM_USER + 100):			
	{
		// 再配置前に親ウィンドウから送られ、サイズを返すメッセージ。
		// DefSubClassTrayProc()を呼ぶとLRESULT形式で、Windows標準時計が入った場合のサイズが帰ってくるので、
		// 改造した場合のサイズに差し替えて戻す。
		// 正しい値を返さないとタスクトレイのサイズがおかしくなる。

		LRESULT ret;

		ret = DefSubclassProc(hwndTrayMain, message, wParam, lParam);

//		CalcMainClockSize();	//ここで呼ばなくてもすでに計算されて正しく入っているはずなのでコメントアウトした

		if (g_bVertTaskbar)
		{
			ret = MAKELONG(LOWORD(ret),
				HIWORD(ret) + heightMainClockFrame - origHeightMainClock);
		}
		else
		{
			ret = MAKELONG(LOWORD(ret) + widthMainClockFrame - origWidthMainClock,
				HIWORD(ret));
		}

		return ret;
	}
	case WM_NOTIFY:
	{
		// 再配置が発生したら親ウィンドウから送られる。
		// DefSubClassTrayProc()を呼ぶとLRESULT形式で返答すべきコード帰ってくるので、そのまま戻せばOKのようだ。
		// この時点で時計は強制的に標準Windows時計のサイズに変更されて、タスクトレイ左上基準にアイテムが並んだ状態(トレイのサイズ自体はWM_USER+100に正しく返していれば確保されている)。
		// hwndClockMainのサイズを改造後サイズに修正して、通知領域などの場所を修正する必要あり(SetMainClockOnTasktrayを呼ぶ。

		LRESULT ret;
		NMHDR *nmh = (NMHDR*)lParam;

		if (nmh->code != PGN_CALCSIZE ||
			g_bTaskbarPosChanging)
			break;

		ret = DefSubclassProc(hwndTrayMain, message, wParam, lParam);	//hwndを明示したが、機能は同じ。

		

		SetMainClockOnTasktray();

		return ret;
	}
	case WM_WINDOWPOSCHANGING:
	{
		BOOL vert;

		vert = IsVertTaskbar(hwndTaskBarMain);
		if (g_bVertTaskbar != vert)
		{
			g_bVertTaskbar = vert;
			g_bTaskbarPosChanging = TRUE;
		}
		else
		{
			g_bTaskbarPosChanging = FALSE;
		}
		break;
	}
	}

	return DefSubclassProc(hwndTrayMain, message, wParam, lParam);
}

//以下の関数は必要ない。将来使う可能性があるので残してある。
//グローバル変数定義(1行)、プロトタイプ宣言(1行)、および以下のコードの3箇所。

//void GetTaskbarMainDimensions()
//{
//	RECT tempRect;
//	GetWindowRect(hwndTrayMain, &tempRect);
//	wTrayMain = tempRect.right - tempRect.left;
//	hTrayMain = tempRect.bottom - tempRect.top;
//
//	GetWindowRect(hwndTaskBarMain, &tempRect);
//	wTaskbarMain = tempRect.right - tempRect.left;
//	hTaskbarMain = tempRect.bottom - tempRect.top;
//
//}



void GetOrigMainClockSize(void)
{
	RECT tempRect;

	if (b_DebugLog)writeDebugLog_Win10("[tclock.c]GetOrigMainClockSize called.", 999);

	GetWindowRect(hwndClockMain, &tempRect);
	origWidthMainClock = tempRect.right - tempRect.left;
	origHeightMainClock = tempRect.bottom - tempRect.top;

}


void StoreSpecificSubClockDimensions(int i)
{

	POINT tempPos = { 0, 0 };
	RECT tempRect;
	char tempClassName[32];
	HWND tempHwnd;

	GetWindowRect(hwndClockSubClk[i], &tempRect);
	origSubClockWidth[i] = tempRect.right - tempRect.left;
	origSubClockHeight[i] = tempRect.bottom - tempRect.top;

	GetWindowRect(hwndTaskBarSubClk[i], &tempRect);
	widthSubTaskbar[i] = tempRect.right - tempRect.left;
	heightSubTaskbar[i] = tempRect.bottom - tempRect.top;


	if (b_DebugLog) {
		writeDebugLog_Win10("[tclock.c][Screen Number = ", i);

		writeDebugLog_Win10("[tclock.c][StoreSpecificSubClockDimensions] origSubClockWidth[i] = ", origSubClockWidth[i]);
		writeDebugLog_Win10("[tclock.c][StoreSpecificSubClockDimensions] origSubClockHeight[i] = ", origSubClockHeight[i]);

		writeDebugLog_Win10("[tclock.c][StoreSpecificSubClockDimensions] widthSubTaskbar[i] = ", widthSubTaskbar[i]);
		writeDebugLog_Win10("[tclock.c][StoreSpecificSubClockDimensions] heightSubTaskbar[i] = ", heightSubTaskbar[i]);
	}
}

void GetOrigSubClkDimensions(void)
{

	for (int i = 0; i < numberSubClk; i++) {
		if (bEnableDrawSubClk[i])
		{
			StoreSpecificSubClockDimensions(i);
			
		}
	}


}


int GetSubClkIndexFromHWND(HWND tempHwndSubClk)
{
//	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] GetSubClkIndexFromHWND called. ", 999);

	HWND tempHwnd;
	int ret = 999;

	for (int i = 0; i < numberSubClk; i++) {
		if (tempHwndSubClk == hwndClockSubClk[i])
		{
			ret = i;
			break;
		}
	}

	if (b_DebugLog) writeDebugLog_Win10("[tclock.c][SetSubClkIndexFromHWND] Index of SubClk = ", ret);

	return ret;
}


void CalcSpecificSubClockSize(int i)
{
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] CalcSpecificSubClockSize called. ", 999);

	RECT tempRect;
	//int widthSubTaskbar[i], heightSubTaskbar[i];

	GetWindowRect(hwndTaskBarSubClk[i], &tempRect);	//この時点でtempRectには対象サブタスクバーの情報が入っている。
	widthSubTaskbar[i] = tempRect.right - tempRect.left;
	heightSubTaskbar[i] = tempRect.bottom - tempRect.top;

	if (g_bVertTaskbar) {
		widthSubClock[i] = tempRect.right - tempRect.left;
		heightSubClock[i] = heightMainClockFrame * widthSubClock[i] / widthMainClockFrame;
		if ((heightSubClock[i] * 2) > heightSubTaskbar[i]) {
			heightSubClock[i] = heightSubTaskbar[i] / 2;
			widthSubClock[i] = heightSubClock[i] * widthMainClockFrame / heightMainClockFrame;
		}
	}
	else {
		heightSubClock[i] = tempRect.bottom - tempRect.top;
		widthSubClock[i] = widthMainClockFrame * heightSubClock[i] / heightMainClockFrame;
		if ((widthSubClock[i] * 2) > widthSubTaskbar[i]) {
			widthSubClock[i] = widthSubTaskbar[i] / 2;
			heightSubClock[i] = widthSubClock[i] * heightMainClockFrame / widthMainClockFrame;
		}
	}

	if (b_DebugLog) {
		writeDebugLog_Win10("[tclock.c][CalcSpecificSubClockSize] widthSubClock[i] = ", widthSubClock[i]);
		writeDebugLog_Win10("[tclock.c][CalcSpecificSubClockSize] heightSubClock[i] = ", heightSubClock[i]);
	}
}


//サブクロックバーでは、いったん出したWindows Inkワークスペースアイコンは無効化しても残っていて、WorkerWの後ろに隠れているだけの場合がある。
//メインバーにも残るが、アイコン幅が0になるので、それで確認することができる。
BOOL GetInkWorkspaceSetting(void)
{
	BOOL ret = FALSE;
	HWND tempHwnd;
	RECT tempRect;

	tempHwnd = FindWindowEx(hwndTrayMain, NULL, "PenWorkspaceButton", NULL);
	if (tempHwnd)
	{
		GetWindowRect(tempHwnd, &tempRect);
		if ((tempRect.right != tempRect.left) && (tempRect.bottom != tempRect.top))
		{
			ret = TRUE;
		}
	}

	if (b_DebugLog)writeDebugLog_Win10("[tclock.c][GetInkWorkspaceSetting] Ink Workspace ON? = ", ret);

	return ret;
}

void SetSpecificSubClock(int i)
{
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] SetSpecificSubClock called. ", 999);

	if (g_bVertTaskbar != IsVertTaskbar(hwndTaskBarSubClk[i])) {
		DisableSpecificSubClock(i);
	}

	if (bEnableDrawSubClk[i])
	{
		POINT pos, nextcorner;
		HWND tempHwnd;
		char tempClassName[32];
		RECT tempRect;
		//int widthSubTaskbar[i], heightSubTaskbar[i];

		//GetWindowRect(hwndTaskBarSubClk[i], &tempRect);	//この時点でtempRectには対象サブタスクバーの情報が入っている。
		//widthSubTaskbar[i] = tempRect.right - tempRect.left;
		//heightSubTaskbar[i] = tempRect.bottom - tempRect.top;

		CalcSpecificSubClockSize(i);

		if (g_bVertTaskbar) {
			nextcorner.x = widthSubTaskbar[i];
			nextcorner.y = heightSubTaskbar[i] - heightSubClock[i];
			SetWindowPos(hwndClockSubClk[i], NULL, 0, nextcorner.y, widthSubClock[i], heightSubClock[i],
				SWP_NOACTIVATE | SWP_NOZORDER);
		}
		else {
			nextcorner.x = widthSubTaskbar[i] - widthSubClock[i];
			nextcorner.y = heightSubTaskbar[i];
			SetWindowPos(hwndClockSubClk[i], NULL, nextcorner.x, 0, widthSubClock[i], heightSubClock[i],
				SWP_NOACTIVATE | SWP_NOZORDER);
		}

		tempHwnd = hwndClockSubClk[i];
		MapWindowPoints(tempHwnd, hwndTaskBarSubClk[i], &pos, 1);

		while ((tempHwnd = GetWindow(tempHwnd, GW_HWNDPREV)) != NULL)
		{
			GetClassName(tempHwnd, tempClassName, sizeof(tempClassName));
			if (strcmp(tempClassName, "PenWorkspaceButton") == 0) {
				//サブクロックバーでは、いったん出したWindows Inkワークスペースアイコンは無効化しても残っていて、WorkerWの後ろに隠れているだけの場合がある。
				//メインバーにもアイコンは残るが、幅0になるので、それで確認することができる(GetInkWorkspaceSetting)。
				GetWindowRect(tempHwnd, &tempRect);
				if (g_bVertTaskbar) {
					SetWindowPos(tempHwnd, NULL, 0, nextcorner.y - (tempRect.bottom + tempRect.top), 0, 0,
						SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
					if (GetInkWorkspaceSetting()) {
						nextcorner.y -= (tempRect.bottom + tempRect.top);					//これをしなければWorkerWが重なってくれる。
					}
				}
				else {
					SetWindowPos(tempHwnd, NULL, nextcorner.x - (tempRect.right - tempRect.left), 0, 0, 0,
						SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
					if (GetInkWorkspaceSetting()) {
						nextcorner.x -= (tempRect.right - tempRect.left);					//ここれをしなければWorkerWが重なってくれる。
					}
				}
				break;
			}
		}

		tempHwnd = hwndClockSubClk[i];
		MapWindowPoints(tempHwnd, hwndTaskBarSubClk[i], &pos, 1);

		while ((tempHwnd = GetWindow(tempHwnd, GW_HWNDPREV)) != NULL)
		{
			GetClassName(tempHwnd, tempClassName, sizeof(tempClassName));
			if (strcmp(tempClassName, "WorkerW") == 0) {
				pos.x = 0;
				pos.y = 0;
				MapWindowPoints(tempHwnd, hwndTaskBarSubClk[i], &pos, 1);
				SetWindowPos(tempHwnd, NULL, pos.x, pos.y, (nextcorner.x - pos.x), (nextcorner.y - pos.y),
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);	//SWP_NOMOVEフラグつきなので実際には位置情報は反映されていない
				break;
			}
		}
	}
}



void SetSubClocksOnTaskbars(void) {
	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] SetSubClocksOnTaskbars called. ", 999);

	for (int i = 0; i < numberSubClk; i++) {
		SetSpecificSubClock(i);
	}
}


void SetTClockFont()
{
	HDC hdc;
	hdc = GetDC(hwndClockMain);
	if (hdc) {
		//	if (hFon) hOldFont = SelectObject(hdc, hFon);
		if (hFon) SelectObject(hdc, hFon);
		ReleaseDC(hwndClockMain, hdc);
	}

	if (hdcClock) {
		//	if (hFon) hOldFont = SelectObject(hdc, hFon);
		if (hFon) SelectObject(hdcClock, hFon);
	}

	if (hdcClock_work) {
		//	if (hFon) hOldFont = SelectObject(hdc, hFon);
		if (hFon) SelectObject(hdcClock_work, hFon);
	}
}


// Added by TTTT for Win10AU (WIN10RS1) compatibility
// Imported from TClockLight-tclocklight-kt160911, dll/Wndproc.c
/*------------------------------------------------
Rearrange the notify area
--------------------------------------------------*/
static void SetMainClockOnTasktray()
{

	//この関数はSubClassTrayProcのWM_NOTIFYからしか呼ばれない(状態を維持すること！)。コール直前にg_OriginalClockWidth, g_OriginalClockHeightが最新の値になっている。


	if (b_DebugLog) writeDebugLog_Win10("[tclock.c] SetMainClockOnTasktray called. ", 999);
	POINT pos, offset;
	HWND tempHwnd;
	//char tempClassName[32];

	GetOrigMainClockSize();
	CalcMainClockSize();

	offset.x = widthMainClockFrame - origWidthMainClock;
	offset.y = heightMainClockFrame -origHeightMainClock;


	//タスクトレイ内では左上を(0,0)としてアイテムが並べられていて、この時点で時計(hwndClockMain)の左上の座標は正しい
	//(ただしSubClassTrayProcのWM_USER + 100に対する返答で正しく答えていれば)ので,時計を移動する必要はない。
	//しかしサイズはWindows標準の時計サイズ(=origClockHeigtとかこのこと。タスクバー高さ等で微妙に変わるので注意が必要だが、この関数コールの直前にSubClassTrayProc内で取得できているはず)。
	//トレイ全体幅と最新のorigClockHeigt, origClockWidthを加味した値を正しく戻していればぴったり収まるはず。


	//サイズとしてClockFrameを使うと実際見えているサイズのビットマップを作ることになる。
	//描画領域外のメモリアクセスエラーが出るようなら、ClockContentのサイズを使うことで、見えない領域まで時計ウィンドウが存在することになる(描画時のメモリエラー予防になる？)
/*	SetWindowPos(hwndClockMain, NULL, 0, 0, widthMainClockContent, heightMainClockContent,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);*/	
	SetWindowPos(hwndClockMain, NULL, 0, 0, widthMainClockFrame, heightMainClockFrame,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);

	//採用したサイズをrectMainClockに収容する。
	rectMainClock.left = 0;
	rectMainClock.right = widthMainClockFrame;
	rectMainClock.top = 0;
	rectMainClock.bottom = heightMainClockFrame;

	//サイズ更新したら、hdcClockを作り直すようにする。CreateClockDCはここから呼ぶだけで必要充分なはず。
	CreateClockDC();


	tempHwnd = hwndClockMain;
	while ((tempHwnd = GetWindow(tempHwnd, GW_HWNDNEXT)) != NULL)		//アプリアイコン等、(Zオーダーが)下位(トレイ上左側)のサブクラスを整理する必要があるためループしている。
	{
		//通知エリアとデスクトップ表示バーが該当するので名前でチェックする必要がありそうだが、やらなくても(コメントアウト)うまくいく。
		//GetClassName(tempHwnd, tempClassName, sizeof(tempClassName));
		//if ((strcmp(tempClassName, "TrayButton") == 0) || (strcmp(tempClassName, "TrayShowDesktopButtonWClass") == 0)){
			pos.x = 0;
			pos.y = 0;
			MapWindowPoints(tempHwnd, hwndTrayMain, &pos, 1);
			if (g_bVertTaskbar) {
				pos.y += offset.y;
			}
			else {
				pos.x += offset.x;
			}
			SetWindowPos(tempHwnd, NULL, pos.x, pos.y, 0, 0,
				SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
		//}
	}

	SetSubClocksOnTaskbars();	//メインクロックの状態が変わったら、毎回サブクロックも反映させる必要あり。

}



void FindAllSubClocks(void)
{
	//dllmain.c.のHookStart()の類似コードだが、サブクロックのスレッドフックは不要なのでtclock.cに収容

	numberSubClk = 0;

	for (int i = 0; i < MAX_SUBSCREEN; i++) {
		hwndTaskBarSubClk[i] = NULL;
		hwndClockSubClk[i] = NULL;
		bSubClockFound[i] = FALSE;
		bEnableDrawSubClk[i] = FALSE;


		if (i == 0) {
			hwndTaskBarSubClk[0] = FindWindowEx(NULL, NULL, "Shell_SecondaryTrayWnd", NULL);
		}
		else {
			hwndTaskBarSubClk[i] = FindWindowEx(NULL, hwndTaskBarSubClk[i - 1], "Shell_SecondaryTrayWnd", NULL);
		}

		if (hwndTaskBarSubClk[i])
		{
			// find the secondary clock window
//			hwndClockSubClk[i] = FindWindowEx(hwndTaskBarSubClk[i], NULL, "ClockButton", NULL);
			hwndClockSubClk[i] = FindWindowEx(hwndTaskBarSubClk[i], NULL, "Windows.UI.Composition.DesktopWindowContentBridge", NULL);
			
			
			//			if (hwndClockSubClk[i]) SendMessage(hwndClockSubClk[i], WM_NULL, 0, 0);		//無くても動きそうだが、一応残す。
			bSubClockFound[i] = TRUE;
			if (b_DebugLog) writeDebugLog_Win10("[dllmain][FindAllSubClocks] Clock Hooked on Sub Screen ID; ", i);
		}
		else {
			numberSubClk = i;
			if (b_DebugLog) {
				writeDebugLog_Win10("[dllmain][FindAllSubClocks] No Clock was found on Sub Screen ID; ", i);
				writeDebugLog_Win10("[dllmain][FindAllSubClocks] numberSubClk = ", numberSubClk);
			}
			break;
		}
	}

}


void DisableSpecificSubClock(int i) {
	char tempClassName[32];
	HWND tempHwnd;

	POINT pos, nextcorner;
	RECT tempRect;

	if (b_DebugLog) {
		writeDebugLog_Win10("[tclock.c]DisableSpecificSubClock called for screen:", i);
	}

	//サブクラス化解除:これを最初にやっておかないと、サブ時計のサイズを戻したのに反応してSetSpecificSubClockが呼ばれてサイズが大きくなってしまう！
	if (bEnableDrawSubClk && hwndClockSubClk[i] && oldWndProcSub[i])
	{
		SubclassWindow(hwndClockSubClk[i], oldWndProcSub[i]);
		//PostMessage(hwndClockSubClk[i], WM_PAINT, 0, 0);
	}
	oldWndProcSub[i] = NULL;


	CalcSpecificSubClockSize(i);	//widthSubTaskbar[i], heightSubTaskbar[i]だけが欲しい

	if (g_bVertTaskbar) {
		nextcorner.x = widthSubTaskbar[i];
		nextcorner.y = heightSubTaskbar[i] - origSubClockHeight[i];

		SetWindowPos(hwndClockSubClk[i], NULL, 0, nextcorner.y, origSubClockWidth[i], origSubClockHeight[i],
			SWP_NOACTIVATE | SWP_NOZORDER);
	}
	else {
		nextcorner.x = widthSubTaskbar[i] - origSubClockWidth[i];
		nextcorner.y = heightSubTaskbar[i];

		SetWindowPos(hwndClockSubClk[i], NULL, nextcorner.x, 0, origSubClockWidth[i], origSubClockHeight[i],
			SWP_NOACTIVATE | SWP_NOZORDER);
	}



	tempHwnd = hwndClockSubClk[i];
	while ((tempHwnd = GetWindow(tempHwnd, GW_HWNDPREV)) != NULL)
	{
		//この処理でWindow ink workspaceのアイコンを移動する。厄介なことにタスクバーの設定でいったん出したアイコンを消した場合、
		//WorkerWの端を重ねて隠すという処理で見えなくしている。
		//だけで、クラスが残っていることがある。
		//正しい状態は、メインタスクトレイのPenWorkSpaceButtonの幅を調べればわかる(GetInkWSpaceSettingを作った)。
		GetClassName(tempHwnd, tempClassName, sizeof(tempClassName));
		if (strcmp(tempClassName, "PenWorkspaceButton") == 0) {
			if (b_DebugLog)writeDebugLog_Win10("[tclock.c][DisableSpecificSubClock] PenWorkspaceButton is recoved", 999);
			GetWindowRect(tempHwnd, &tempRect);
			if (g_bVertTaskbar) {
				SetWindowPos(tempHwnd, NULL, 0, nextcorner.y - (tempRect.bottom + tempRect.top), 0, 0,
					SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
				if (GetInkWorkspaceSetting()) {
					nextcorner.y -= (tempRect.bottom + tempRect.top);			//こうしなければ次の処理でWorkerWが重なってくれる。

				}

			}
			else {
				SetWindowPos(tempHwnd, NULL, nextcorner.x - (tempRect.right - tempRect.left), 0, 0, 0,
					SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
				if (GetInkWorkspaceSetting()) {
					nextcorner.x -= (tempRect.right - tempRect.left);			//こうしなければ次の処理でWorkerWが重なってくれる。
				}
			}
			break;
		}
	}


	tempHwnd = hwndClockSubClk[i];
	while ((tempHwnd = GetWindow(tempHwnd, GW_HWNDPREV)) != NULL)
	{
		GetClassName(tempHwnd, tempClassName, sizeof(tempClassName));
		if (strcmp(tempClassName, "WorkerW") == 0) {
			pos.x = 0;
			pos.y = 0;
			MapWindowPoints(tempHwnd, hwndTaskBarSubClk[i], &pos, 1);
			SetWindowPos(tempHwnd, NULL, pos.x, pos.y, (nextcorner.x - pos.x), (nextcorner.y - pos.y),
				SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);	//SWP_NOMOVEフラグつきなので実際には位置情報は反映されていない
			break;
		}
	}



	if (hwndClockSubClk[i]) {
		PostMessage(hwndClockSubClk[i], WM_SIZE, SIZE_RESTORED, 0);	//サブクロックは元に戻したウィンドウプロシージャにこれを送っておかないと再描画されない。
	}
	hwndClockSubClk[i] = NULL;

	// refresh the taskbar
	if (hwndTaskBarSubClk[i])
	{
		PostMessage(hwndTaskBarSubClk[i], WM_SIZE, SIZE_RESTORED, 0);
//		InvalidateRect(hwndTaskBarSubClk[i], NULL, TRUE);		//MainClock同様、これはなくてもよさそう。
	}
	hwndTaskBarSubClk[i] = NULL;

	bSubClockFound[i] = FALSE;

	bEnableDrawSubClk[i] = FALSE;

	//ここではあえてnumberSubClkは減らさない(bEnableDrawSubClk[i]=FALSEにするので大丈夫)
}


void DisableAllSubClocks(void)
{
	for (int i = 0; i < numberSubClk; i++) {
		if (bEnableDrawSubClk[i])
		{
			DisableSpecificSubClock(i);
		}
	}
	bEnableSubClks = FALSE;
	numberSubClk = 0;
}



// Added by TTTT for Win10AU (WIN10RS1) compatibility
// Imported from TClockLight-tclocklight-kt160911, dll/Wndproc.c
/*------------------------------------------------
vertical taskbar ?
--------------------------------------------------*/
BOOL IsVertTaskbar(HWND temphwndTaskBarMain)
{
	RECT tempRect;

	GetWindowRect(temphwndTaskBarMain, &tempRect);
	return (tempRect.bottom - tempRect.top) > (tempRect.right - tempRect.left);

}



/*------------------------------------------------
　SafeMode判定と起動時刻(Tick)保存
 --------------------------------------------------*/
void CheckSafeMode_Win10(void)
{
	//hwnd使われていない


	FILETIME currentLaunchFileTime;
	currentLaunchFileTime.dwHighDateTime = 0;
	currentLaunchFileTime.dwLowDateTime = 0;


	LONG currentLaunchTimeStamp = 0;
	LONG lastLaunchTimeStamp = 0;

	GetSystemTimeAsFileTime(&currentLaunchFileTime);
	currentLaunchTimeStamp = (((currentLaunchFileTime.dwHighDateTime & 0x000FFFFF) << 9)
			+ (currentLaunchFileTime.dwLowDateTime >> 23)) * 0.839;


	lastLaunchTimeStamp = GetMyRegLong("Status_DoNotEdit", "LastLaunchTimeStamp", 0);
	SetMyRegLong("Status_DoNotEdit", "LastLaunchTimeStamp", currentLaunchTimeStamp);
	LONG timeStampDifference = currentLaunchTimeStamp - lastLaunchTimeStamp;

	if ((timeStampDifference > 0) && (timeStampDifference < 20))
	{
		b_SafeMode = TRUE;
	}
	else {
		b_SafeMode = FALSE;
	}

	b_ExcessNetProfiles = GetMyRegLong("Status_DoNotEdit", "ExcessNetProfiles", FALSE);
	SetMyRegLong("Status_DoNotEdit", "ExcessNetProfiles", FALSE);
	if (b_ExcessNetProfiles) b_SafeMode = TRUE;


	SetMyRegLong("Status_DoNotEdit", "SafeMode", b_SafeMode);
	
	b_DebugLog = GetMyRegLong(NULL, "DebugLog", FALSE);

	if (b_DebugLog) writeDebugLog_Win10("lastLaunchTimeStamp = ", lastLaunchTimeStamp);
	if (b_DebugLog) writeDebugLog_Win10("currentLaunchTimeStamp = ", currentLaunchTimeStamp);
	if (b_DebugLog) writeDebugLog_Win10("timeStampDifference = ", timeStampDifference);
	if (b_DebugLog) writeDebugLog_Win10("b_SafeMode = ", b_SafeMode);



}



COLORREF MyColorTT_Core(int iCPU)
{
	COLORREF returnvalue;
	if (iCPU > 66)
	{
		returnvalue = ColorBarMeterCore_High;
	}
	else if (iCPU > 33)
	{
		returnvalue = ColorBarMeterCore_Mid;
	}
	else if (iCPU > 0)
	{
		returnvalue = ColorBarMeterCore_Low;
	}
	return returnvalue;
}


COLORREF MyColorTT_CU()
{
	COLORREF returnvalue;
	if (iCPUUsage > 66)
		{
			returnvalue = ColorBarMeterCU_High;
		}
		else if (iCPUUsage > 33)
		{
			returnvalue = ColorBarMeterCU_Mid;
		}
		else if (iCPUUsage > 0)
		{
			returnvalue = ColorBarMeterCU_Low;
		}
	return returnvalue;
}


COLORREF MyColorTT_VL()
{
	COLORREF returnvalue;
		if (muteStatus)
		{
			returnvalue = ColorBarMeterVL_Mute;
		}
		else
		{
			returnvalue = ColorBarMeterVL;
		}
		return returnvalue;
}


COLORREF MyColorTT_BL()
{
	COLORREF returnvalue;

	if (b_Charging)
	{
		returnvalue = ColorBarMeterBL_Charge;
	}
	else if (iBatteryLife > 49)
	{
		returnvalue = ColorBarMeterBL_High;
	}
	else if (iBatteryLife > 19)
	{
			returnvalue = ColorBarMeterBL_Mid;
	}
	else if (iBatteryLife > 0)
	{
		returnvalue = ColorBarMeterBL_Low;
	}


	return returnvalue;
}



void checkDisplayStatus_Win10(void)
{




	DWORD dwFlags = 1;
	int iDevNum = 0;
	int activeDevNum = 0;
	int lastActiveDevNum = 0;
	BOOL primaryDevFlag[32];
	DISPLAY_DEVICE myDisplayDevice;
	myDisplayDevice.cb = sizeof(DISPLAY_DEVICE);
	DEVMODE mode;

	if (b_DebugLog) writeDebugLog_Win10("checkDisplayStatus_Win10 called", 999);


	while (EnumDisplayDevices(NULL, iDevNum, &myDisplayDevice, dwFlags))
	{
		iDevNum++;

		//各モニタの情報を取得、テスト用。
		//EnumDisplaySettings(myDisplayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &mode);
		//if (b_DebugLog) {
		//	writeDebugLog_Win10("[tclock.c][checkDisplayStatus_Win10] Display #: ", iDevNum);
		//	writeDebugLog_Win10("[tclock.c][checkDisplayStatus_Win10] mode.dmPelsWidth = ", mode.dmPelsWidth);
		//	writeDebugLog_Win10("[tclock.c][checkDisplayStatus_Win10] mode.dmPelsHeight = ", mode.dmPelsHeight);
		//	writeDebugLog_Win10("[tclock.c][checkDisplayStatus_Win10] mode.dmBitsPerPixel = ", mode.dmBitsPerPel);
		//}


		if (myDisplayDevice.StateFlags & DISPLAY_DEVICE_ACTIVE)
		{
			activeDevNum++;
			lastActiveDevNum = iDevNum;
		}

		if (myDisplayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
		{
			primaryDevFlag[iDevNum] = TRUE;
		}
		else
		{
			primaryDevFlag[iDevNum] = FALSE;
		}


	}

	EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)myMonitorEnumProc, 0);

	if (activeDevNum == 1)
	{
		if (b_FlagDispClone)
		{
			strcpy(strDispStatus, strDispClone);
		}
		else
		{
			strcpy(strDispStatus, strDispSingle);
		}
	}
	else
	{
		strcpy(strDispStatus, strDispExtend);
	}


}



void CALLBACK myMonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)
{

	b_FlagDispClone = FALSE;

	MONITORINFOEX monitorInfo;
	monitorInfo.cbSize = sizeof(monitorInfo);
	GetMonitorInfo(hMonitor, &monitorInfo);


	if (monitorInfo.dwFlags & MONITORINFOF_PRIMARY)
	{
		DWORD  NumPhysMon;
		GetNumberOfPhysicalMonitorsFromHMONITOR(hMonitor, &NumPhysMon);

		if (NumPhysMon != 1) b_FlagDispClone = TRUE;
	}
}

void RestartTClockFromDLL(void)
{
	if (b_DebugLog) writeDebugLog_Win10("TClock will be restarted ...", 999);
	SetMyRegLong("Status_DoNotEdit", "LastLaunchTimeStamp", 0);
	char fname[MAX_PATH];
	strcpy(fname, g_mydir_dll);
	add_title(fname, "TClock-Win10.exe");
	ShellExecute(NULL, "open", fname, "/restart", NULL, SW_HIDE);
	//EndClock(hwndClock);
}


BOOL IsHoliday_Win10(SYSTEMTIME* pt)
{
	if (b_English) return (FALSE);

	BOOL b_ret = FALSE;
	int Year, Month, Day, DoW;
	Year = pt->wYear;
	Month = pt->wMonth;
	Day = pt->wDay;
	DoW = pt->wDayOfWeek;

	switch(Month) {
		case 1:
			if (Day == 1 || (Day == 2 && DoW == 1)) b_ret = TRUE;
			if (Day > 7 && Day < 15 && DoW == 1) b_ret = TRUE;
			break;
		case 2:
			if (Day == 11 || (Day == 12 && DoW == 1)) b_ret = TRUE;
			if (Day == 23 || (Day == 24 && DoW == 1)) b_ret = TRUE;
			break;
		case 3:
			if (Year == 2020 || Year == 2021 || Year == 2024 || Year == 2025 || Year == 2026 || Year == 2028 || Year == 2029 || Year == 2030)
				if (Day == 20 || (Day == 21 && DoW == 1)) b_ret = TRUE;
			if (Year == 2022 || Year == 2023 || Year == 2027)
				if (Day == 21 || (Day == 22 && DoW == 1)) b_ret = TRUE;
			break;
		case 4:
			if (Day == 29 || (Day == 30 && DoW == 1)) b_ret = TRUE;
			break;
		case 5:
			if (Day == 3) b_ret = TRUE;
			if (Day == 4) b_ret = TRUE;
			if (Day == 5) b_ret = TRUE;
			if (Day == 6 && (DoW == 1 || DoW == 2 || DoW == 3)) b_ret = TRUE;
			break;
		case 7:
			if (Year == 2020) {
				if (Day == 23) b_ret = TRUE;
			}
			else {
				if (Day > 14 && Day < 22 && DoW == 1) b_ret = TRUE;
			}
			break;
		case 8:
			if (Year == 2020) {
				if (Day == 10) b_ret = TRUE;
			}
			else {
				if (Day == 11 || (Day == 12 && DoW == 1)) b_ret = TRUE;
			}
			break;
		case 9:
			if (Day > 14 && Day < 22 && DoW == 1) b_ret = TRUE;
			if (Year == 2020 || Year == 2024 || Year == 2028)
				if (Day == 22 || (Day == 23 && DoW == 1)) b_ret = TRUE;
			if (Year == 2021 || Year == 2022 || Year == 2023 || Year == 2025 || Year == 2026 || Year == 2027 || Year == 2029 || Year == 2030)
				if (Day == 23 || (Day == 24 && DoW == 1)) b_ret = TRUE;
			break;
		case 10:
			if (Year != 2020) {
				if (Day > 7 && Day < 15 && DoW == 1) b_ret = TRUE;
			}
			break;
		case 11:
			if (Day == 3 || (Day == 4 && DoW == 1)) b_ret = TRUE;
			if (Day == 23 || (Day == 24 && DoW == 1)) b_ret = TRUE;
	}
	return(b_ret);
}





void Check_Light_Theme_Win10(void)
{
	if (b_DebugLog)
	{
		writeDebugLog_Win10("[tclock.c][Check_Light_Theme_Win10] Check_Light_Theme_Win10 called.", 999);
	}


	HKEY hkey;
	DWORD reg_data;
	DWORD regtype, size;
	size = sizeof(DWORD);

	b_System_Light_Theme = FALSE;
	b_Apps_Light_Theme = FALSE;
	b_Transparency_Theme = FALSE;

	if (RegOpenKeyEx(HKEY_CURRENT_USER, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize", 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS) {
		if (RegQueryValueEx(hkey, "AppsUseLightTheme", 0, &regtype, (LPBYTE)&reg_data, &size) == ERROR_SUCCESS)
		{
			if (reg_data == 1) b_Apps_Light_Theme = TRUE;
			if (b_DebugLog)
			{
				writeDebugLog_Win10("[tclock.c][Check_Light_Theme_Win10] b_Apps_Light_Theme = ", b_Apps_Light_Theme);
			}
		}
		if (RegQueryValueEx(hkey, "SystemUsesLightTheme", 0, &regtype, (LPBYTE)&reg_data, &size) == ERROR_SUCCESS)
		{
			if (reg_data == 1) b_System_Light_Theme = TRUE;
			if (b_DebugLog)
			{
				writeDebugLog_Win10("[tclock.c][Check_Light_Theme_Win10] b_System_Light_Theme = ", b_System_Light_Theme);
			}
		}
		if (RegQueryValueEx(hkey, "EnableTransparency", 0, &regtype, (LPBYTE)&reg_data, &size) == ERROR_SUCCESS)
		{
			if (reg_data == 1) b_Transparency_Theme = TRUE;
			if (b_DebugLog)
			{
				writeDebugLog_Win10("[tclock.c][Check_Light_Theme_Win10] b_Transparency_Theme = ", b_Transparency_Theme);
			}
		}

		RegCloseKey(hkey);
	}
}

